console.clear()


namespace DecoratorFactory {
    function isDecoratorContext(arg: unknown): arg is DecoratorContext {
        return typeof arg === 'object' && arg !== null && ['kind','name'].every(key=>Object.hasOwn(arg,key))
    }
    function isFactoryCall(...args: unknown[]) {
        return !((typeof args[0] === 'function' || typeof args[0] === 'undefined') && isDecoratorContext(args[1])); 
    }
    export function invokeDefault(value: Class | Function, context: DecoratorContext, ...args: unknown[]) {
        return context.kind === 'class' ? new (value as DecoratorFactory.Class)(...args) : (value as DecoratorFactory.Function)(...args)
    }
    export function decorator<Context extends DecoratorContext, Args extends Array<unknown>,Value,Return extends Function | void>(f: (value: Value, context: Context, ...args: Partial<Args>) => Return) {
        function decorate(...args: Partial<Args>): (value: Value, context: Context)=>Return;
        function decorate(value: Value, context: Context): Return;
        function decorate(...args: Partial<Args> | [Value, Context]) {
            if(isFactoryCall(...args)) {
                return (value: Value, context: Context) => value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,args) : f(value, context, ...args as Args);
            } else {
                const [value, context] = args as [Value, Context];
                return value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,[] as unknown[] as Args) : f(value, context, ...([] as unknown[] as Args));
            }
        }
        return decorate;
    }
    export type Class<A extends Array<unknown> = any[], R = any> = new (...args: A) => R;
    export type Function<A extends Array<unknown> = any[], R = any> = (...args: A) => R
}

namespace KITSUNE_NAMESPACE {
    export const addLazyDecoratorSymbol = Symbol('addLazyDecorator');
}

///#pragma once
type SubTree<K extends Tree = Tree> = K & { parent: Tree };
type StrayTree<K extends Tree = Tree> = K & { parent: undefined };

abstract class Tree {
    readonly #children: SubTree<typeof this>[] = [];
    #parent: typeof this | undefined = undefined;

    get parent(): typeof this | undefined {
        return this.#parent;
    }

    #disown(other: undefined): undefined;
    #disown(other: typeof this): StrayTree<typeof this>;
    #disown(other: typeof this | undefined): StrayTree<typeof this> | undefined;
    #disown(other: typeof this | undefined): StrayTree<typeof this> | undefined {
        if (other !== undefined) {
            other.#parent = undefined;
        }
        return other as StrayTree<typeof this> | undefined;
    }

    #own(other: undefined): never;
    #own(other: Tree): SubTree<typeof this>;
    #own(other: Tree | undefined): SubTree<typeof this>;
    #own(other: Tree | undefined): SubTree<typeof this> {
        if (other === undefined) {
            throw new Error('Cannot take ownership of undefined');
        }
        if (other === this) {
            throw new Error('Cannot take ownership of self');
        }
        if (other.parent !== undefined) {
            throw new Error('Cannot take ownership of a subtree');
        }

        let ancestor: typeof this | undefined = this;
        do {
            if (ancestor === other) {
                throw new Error('Cannot take ownership of ancestor');
            }
        } while (ancestor = ancestor.parent);

        other.#parent = this;
        return other as SubTree<typeof this>;
    }

    protected push(...items: typeof this[]): number {
        return this.#children.push(...items.map(tree => this.#own(tree)));
    }
    protected pop(): StrayTree<typeof this> | undefined {
        return this.#disown(this.#children.pop());
    }

    protected unshift(...items: typeof this[]): number {
        return this.#children.unshift(...items.map(tree => this.#own(tree)));
    }
    protected shift(): StrayTree<typeof this> | undefined {
        return this.#disown(this.#children.shift());
    }

    protected splice(start: number, deleteCount?: number | undefined): StrayTree<typeof this>[];
    protected splice(start: number, deleteCount: number, ...items: typeof this[]): StrayTree<typeof this>[];
    protected splice(start: number, deleteCount: number, ...items: typeof this[]): StrayTree<typeof this>[] {
        return this.#children.splice(start, deleteCount, ...items.map(tree => this.#own(tree))).map(tree => this.#disown(tree));
    }

    protected at(index: number): SubTree<typeof this> | undefined {
        return this.#children.at(index) as SubTree<typeof this> | undefined;
    }

    protected get length(): number {
        return this.#children.length;
    }

    protected forEach(callbackfn: (value: SubTree<typeof this>, index: number, parent: typeof this) => void, thisArg?: any): void {
        if (thisArg !== undefined) {
            callbackfn = callbackfn.bind(thisArg);
        }
        return this.#children.forEach((tree, index) => callbackfn(tree, index, this));
    }

    protected values(): IterableIterator<typeof this> {
        return this.#children.values();
    }

    get [Symbol.toStringTag]() {
        return 'Tree';
    }

    protected [Symbol.iterator]() {
        return this.#children[Symbol.iterator]();
    }
}

const enumerable = DecoratorFactory.decorator((_,context: ClassGetterDecoratorContext | ClassFieldDecoratorContext | ClassAccessorDecoratorContext, enumerable: boolean = true) => context.addInitializer(function() {
    Object.defineProperty(this, context.name, {...Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this),context.name), enumerable});
}));

type ArrayTreeMethods = Pick<Array<ArrayTree>, 'length' | 'values' | 'at' | 'push' | 'unshift' | 'pop' | 'shift' | 'splice' | typeof Symbol.iterator>;
class ArrayTree extends Tree implements ArrayTreeMethods {
    public override get length() {
        return super.length;
    }

    public override at = super.at;
    public override values = super.values;
    public override push = super.push;
    public override unshift = super.unshift;
    public override pop = super.pop;
    public override shift = super.shift;
    public override splice = super.splice;
    public override [Symbol.iterator] = super[Symbol.iterator];

    @enumerable
    get children() {
        return [...this];
    }
    
    get [Symbol.toStringTag]() {
        return 'ArrayTree';
    }
}

class BinaryTree extends Tree {
    set left(value: Tree) {
        this.splice(0,1,value);
    }
    @enumerable get left(): Tree | undefined {
        return this.at(0)
    }
    set right(value: Tree) {
        this.splice(1,1,value);
    }
    @enumerable get right(): Tree | undefined {
        return this.at(1)
    }
}

const x = new ArrayTree();
x.push(new ArrayTree())
x.at(0)
console.log(x)
console.log(new BinaryTree())
console.log(new BinaryTree())


















































console.clear();


declare namespace OpaqueTypes {
    const type: unique symbol;
    export type Opaque<T,Ident> = T & {[type]:Ident};
}
type Opaque<T,Ident> = OpaqueTypes.Opaque<T,Ident>;

class Base {

}


type self = Opaque<unknown,'self'>;
// type ResolveSelfType<T> = ;

class Derived<T extends Base = Base, InferedType = NoInfer<T extends self ? Derived<T> : T>> extends Base {
    constructor(public value?: InferedType) {super();};
    a=1
    get it() {
        return this.value!
    }
}

class Other extends Base {}


const x = new Derived(new Base())
const y = new Derived<self>(new Other());
const k = new Derived<self>(new Derived<Other>());
const n = new Derived<self>(new Derived<Base>());
const m = new Derived<self>(new Derived<self>());
const j = new Derived(new Derived());
k.it
const z = new Derived(new Other());
















































































































console.clear()


namespace DecoratorFactory {
    function isDecoratorContext(arg: unknown): arg is DecoratorContext {
        return typeof arg === 'object' && arg !== null && ['kind','name'].every(key=>Object.hasOwn(arg,key))
    }
    function isFactoryCall(...args: unknown[]) {
        return !((typeof args[0] === 'function' || typeof args[0] === 'undefined') && isDecoratorContext(args[1])); 
    }
    export function invokeDefault(value: Class | Function, context: DecoratorContext, ...args: unknown[]) {
        return context.kind === 'class' ? new (value as DecoratorFactory.Class)(...args) : (value as DecoratorFactory.Function)(...args)
    }
    export function decorator<Context extends DecoratorContext, Args extends Array<unknown>,Value,Return extends Function | void>(f: (value: Value, context: Context, ...args: Partial<Args>) => Return) {
        function decorate(...args: Partial<Args>): (value: Value, context: Context)=>Return;
        function decorate(value: Value, context: Context): Return;
        function decorate(...args: Partial<Args> | [Value, Context]) {
            if(isFactoryCall(...args)) {
                return (value: Value, context: Context) => value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,args) : f(value, context, ...args as Args);
            } else {
                const [value, context] = args as [Value, Context];
                return value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,[] as unknown[] as Args) : f(value, context, ...([] as unknown[] as Args));
            }
        }
        return decorate;
    }
    export type Class<A extends Array<unknown> = any[], R = any> = new (...args: A) => R;
    export type Function<A extends Array<unknown> = any[], R = any> = (...args: A) => R
}

namespace KITSUNE_NAMESPACE {
    export const addLazyDecoratorSymbol = Symbol('addLazyDecorator');
}

///#pragma once
const enumerable = DecoratorFactory.decorator((_,context: ClassGetterDecoratorContext | ClassFieldDecoratorContext | ClassAccessorDecoratorContext, enumerable: boolean = true) => context.addInitializer(function() {
    Object.defineProperty(this, context.name, {...Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this),context.name), enumerable});
}));

type SubTree<K extends Tree = Tree> = K & { parent: Tree };
type StrayTree<K extends Tree = Tree> = K & { parent: undefined };

abstract class Tree {
    readonly #children: SubTree<Tree>[] = [];
    #parent: Tree | undefined = undefined;

    get parent(): Tree | undefined {
        return this.#parent;
    }

    #disown(other: undefined): undefined;
    #disown(other: Tree): StrayTree<Tree>;
    #disown(other: Tree | undefined): StrayTree<Tree> | undefined;
    #disown(other: Tree | undefined): StrayTree<Tree> | undefined {
        if (other !== undefined) {
            other.#parent = undefined;
        }
        return other as StrayTree<Tree> | undefined;
    }

    #own(other: undefined): never;
    #own(other: Tree): SubTree<Tree>;
    #own(other: Tree | undefined): SubTree<Tree>;
    #own(other: Tree | undefined): SubTree<Tree> {
        if (other === undefined) {
            throw new Error('Cannot take ownership of undefined');
        }
        if (other === this) {
            throw new Error('Cannot take ownership of self');
        }
        if (other.parent !== undefined) {
            throw new Error('Cannot take ownership of a subtree');
        }

        let ancestor: Tree | undefined = this;
        do {
            if (ancestor === other) {
                throw new Error('Cannot take ownership of ancestor');
            }
        } while (ancestor = ancestor.parent);

        other.#parent = this;
        return other as SubTree<Tree>;
    }

    protected push(...items: Tree[]): number {
        return this.#children.push(...items.map(tree => this.#own(tree)));
    }
    protected pop(): StrayTree<Tree> | undefined {
        return this.#disown(this.#children.pop());
    }

    protected unshift(...items: Tree[]): number {
        return this.#children.unshift(...items.map(tree => this.#own(tree)));
    }
    protected shift(): StrayTree<Tree> | undefined {
        return this.#disown(this.#children.shift());
    }

    protected splice(start: number, deleteCount?: number | undefined): StrayTree<Tree>[];
    protected splice(start: number, deleteCount: number, ...items: Tree[]): StrayTree<Tree>[];
    protected splice(start: number, deleteCount: number, ...items: Tree[]): StrayTree<Tree>[] {
        return this.#children.splice(start, deleteCount, ...items.map(tree => this.#own(tree))).map(tree => this.#disown(tree));
    }

    protected at(index: number): SubTree<Tree> | undefined {
        return this.#children.at(index) as SubTree<Tree> | undefined;
    }

    protected get length(): number {
        return this.#children.length;
    }

    protected forEach(callbackfn: (value: SubTree<Tree>, index: number, parent: Tree) => void, thisArg?: any): void {
        if (thisArg !== undefined) {
            callbackfn = callbackfn.bind(thisArg);
        }
        return this.#children.forEach((tree, index) => callbackfn(tree, index, this));
    }

    protected values(): IterableIterator<Tree> {
        return this.#children.values();
    }

    get [Symbol.toStringTag]() {
        return 'Tree';
    }

    protected [Symbol.iterator]() {
        return this.#children[Symbol.iterator]();
    }
}

type ArrayTreeMethods = Pick<Array<Tree>, 'length' | 'values' | 'at' | 'push' | 'unshift' | 'pop' | 'shift' | 'splice' | typeof Symbol.iterator>;
class ArrayTree extends Tree implements ArrayTreeMethods {
    public override get length() {
        return super.length;
    }

    public override at = super.at;
    public override values = super.values;
    public override push = super.push;
    public override unshift = super.unshift;
    public override pop = super.pop;
    public override shift = super.shift;
    public override splice = super.splice;
    public override [Symbol.iterator] = super[Symbol.iterator];

    @enumerable get children() {
        return [...this];
    }
    
    get [Symbol.toStringTag]() {
        return 'ArrayTree';
    }
}

class BinaryTree extends Tree {
    set left(value: Tree) {
        this.splice(0,1,value);
    }
    @enumerable get left(): SubTree<Tree> | undefined {
        return this.at(0)
    }
    set right(value: Tree) {
        this.splice(1,1,value);
    }
    @enumerable get right(): SubTree<Tree> | undefined {
        return this.at(1)
    }
    get [Symbol.toStringTag]() {
        return 'BinaryTree';
    }
    args: Tree[]
    bargs: {a: Tree}
    foo(t: Tree,x:number): Tree {
        throw 'nyi'
    }
}

class DummyTree extends Tree {}

type RestructureTreeType<Type,T extends Tree> =
    Type extends Tree ? NestedTree<T>
    // : Type extends SubTree<any> ?   NestedSubTree<T>
    // : Type extends StrayTree<any> ? NestedStrayTree<T>
    // : Type extends Function ? never //? (...args: RestructureTreeType<Parameters<Type>,T>)=>RestructureTreeType<ReturnType<Type>,T>,
    // : Type extends [...any] ? {[key in keyof Type]: RestructureTreeType<Type[key],T>}
    // : Type extends object ? {[key in keyof Type]: RestructureTreeType<Type[key],T>}
    // : Type extends (...args: infer Args) => infer ReturnType ? (...args: RestructureTreeType<Args,T>) => (RestructureTreeType<ReturnType,T>)
    : Type
    
type NestedTree<T extends Tree> = T & {[key in keyof T]: RestructureTreeType<T[key],T>}
type NestedStrayTree<T extends Tree> = StrayTree<NestedTree<T>>;
type NestedSubTree<T extends Tree> = SubTree<NestedTree<T>>;

const x = new ArrayTree();
x.push(new ArrayTree())
x.at(0)
console.log(x)
console.log(new BinaryTree())
console.log(new BinaryTree())
const bt = new BinaryTree()
bt.left = new BinaryTree();
bt.right = new ArrayTree();
console.log(bt)


const bt2 = new BinaryTree() as NestedTree<BinaryTree>;
bt2.left = new BinaryTree() as NestedTree<BinaryTree>;
bt2.right = new ArrayTree() as NestedTree<BinaryTree>;
bt2.foo(new ArrayTree(),0)



const a1 = new ArrayTree() as NestedTree<ArrayTree>;
a1.push(new BinaryTree())
const z: BinaryTree = a1.pop();





































///#pragma once

///#include <compat.ts>
///#include <types.ts>
///#include <tree.ts>
///#include <peek.ts>

///#include "cfg.ts"

namespace LL1 {
    export type LL1ParseTable = Map<NonTerminal,Map<Terminal,number>>;
    
    type SyntaxTransformer<ASTNodeType extends Tree<unknown>> = (node: ParseTree<ASTNodeType>)=>typeof node | ASTNodeType | ASTNodeType[] | null

    export type SyntaxTransformerMap<ASTNodeType extends Tree<unknown>> = Map<NonTerminal | '*', SyntaxTransformer<ASTNodeType>>;

    type TreeT<ASTNodeType extends Tree<unknown>=never> = NonTerminal | Token | typeof CFG.EOF_CHARACTER | typeof CFG.LAMBDA_CHARACTER | ASTNodeType;

    export type ParseTree<ASTNodeType extends Tree=never> = StrayTree<NestedTree<ArrayTree|ASTNodeType>>;

    function convertLeftRecursion(cfg: CFG): CFG {
        const newRules = new Map<NonTerminal,CFGRuleBody[]>()
    
        function getTailOverrlap<T>(a: T[], b: T[]) {
            let overlap: T[] = [];
            let i = -1;
            while(a.at(i) === b.at(i) && a.at(i) !== undefined) {
                overlap.unshift(a.at(i--)!);
            }
            return overlap;
        }
    
        function arrayEquals<T>(a: T[], b: T[]) {
            return a.length === b.length && a.every((e, i) => e === b[i]);
        }
    
        for(const N of cfg.getNonTerminals()) {
            // Sort by descending length to ensure we see non lambda rules first
            const rules = new Set(cfg.getRuleListFor(N).sort(([lhsA,rhsA],[lhsB,rhsB])=>rhsB.length-rhsA.length));
            newRules.set(N,[]);
    
            refactor:
            for(const [lhs1,rhs1,ref1] of rules.values().map(r=>[...r,r] as [NonTerminal,CFGRuleBody,CFGRule])) {
                if(rhs1[0] === lhs1) {
                    for(const [lhs2,rhs2,ref2] of rules.values().map(x=>[...x,x] as [NonTerminal,CFGRuleBody,CFGRule])) {
                        if(rhs1 === rhs2) {
                            continue;
                        }
    
                        const beta = getTailOverrlap(rhs1,rhs2);
                        
                       if(arrayEquals(rhs2,beta)) {
                            const A = lhs1;
                            const gamma = rhs1.slice(1,rhs1.length-beta.length);
                            rules.delete(ref1);
                            rules.delete(ref2); // Don't visit again
    
                            const R = CFG.makeUniqueNonTerminal(cfg,N);
    
                            newRules.get(N)!.push([...beta,R]);
                            newRules.set(R, [[...gamma, ...beta, R],[]]);
                            continue refactor;
                       }
                    }
                }
    
                newRules.get(N)!.push(rhs1); // No refactor happened
            }
        }
    
        return new CFG(cfg.startingSymbol, newRules, new Set(cfg.getTerminals()));
    }

    function leftFactor(cfg: CFG): CFG {
        const newRules = new Map<NonTerminal,CFGRuleBody[]>()
    
        for(const N of cfg.getNonTerminals()) {
            const rules = new Set(cfg.getRuleListFor(N));
            newRules.set(N,[]);
    
            for(const [lhs1,rhs1,ref1] of rules.values().map(r=>[...r,r] as [NonTerminal,CFGRuleBody,CFGRule])) {
                if(rhs1.length < 1) {
                    newRules.get(N)!.push(rhs1);
                    continue;
                }
                
                const pre1 = rhs1[0];
                const W = CFG.makeUniqueNonTerminal(cfg,N);
                let anyOverlaps = false;
    
                for(const [lhs2,rhs2,ref2] of rules.values().map(r=>[...r,r] as [NonTerminal,CFGRuleBody,CFGRule])) { 
                    const pre2 = rhs2[0];
                    if(rhs1 !== rhs2 && pre1 === pre2) {
                        if(!anyOverlaps) {
                            newRules.set(W,[]);
                        }
                        anyOverlaps = true;
    
                        newRules.get(W)!.push(rhs2.slice(1));
                        rules.delete(ref2);
                    }
                }
    
                if(anyOverlaps) {
                    newRules.get(W)!.push(rhs1.slice(1));
                    newRules.get(N)!.push([pre1,W]);
                    rules.delete(ref1);
                } else {
                    newRules.get(N)!.push(rhs1);
                }
            }
        }
    
        return new CFG(cfg.startingSymbol, newRules, new Set(cfg.getTerminals()));
    }

    // Note, some of the optimizations can't see through  A -> B -> C rules
    // Ideally, we'd optimize those out first, but that's nyi (or maybe compare with first sets?)
    function transform(cfg: CFG): CFG {
        let k;
        do {
            k = cfg.getRuleList().length;
            cfg = leftFactor(cfg);
        } while(k != cfg.getRuleList().length);

        return convertLeftRecursion(cfg);
    }

    function createParseTable(cfg: CFG): LL1ParseTable {
        const parseTable: LL1ParseTable = new Map(cfg.getNonTerminals().map(N=>[N,new Map(cfg.getTerminalsAndEOF().map(a => [a,-1]))]));
        let i = 0;
        for(const lhs of cfg.getNonTerminals()) {
            const rules = cfg.getRuleListFor(lhs).map(([_,rhs])=>rhs);
            const row = parseTable.get(lhs)!;
            for(const rhs of rules) {
                const P = cfg.predictSet([lhs,rhs]);
                for(const a of P) {
                    if(row.get(a) != -1) {
                        // Possibly implement C hack for dangling bracket here later on or just mark issue
                        throw new Error(`Grammar is not LL(1) (Caused by rules ${row.get(a)} and ${i})`);
                    } else {
                        row.set(a,i);
                    }
                }
                i++;
            }
        }
        return parseTable;
    }

    export class LL1Parser<ASTNodeType extends Tree=never> {
        private readonly parseTable: LL1ParseTable;
        private readonly cfg: CFG;
        private readonly sdt: SyntaxTransformerMap<ASTNodeType>; 
        constructor(cfg: CFG, sdt: {[key in NonTerminal | '*']?: SyntaxTransformer<ASTNodeType>} | SyntaxTransformerMap<ASTNodeType> = new Map()) {
            this.cfg = transform(cfg);
            this.parseTable = createParseTable(this.cfg);
            this.sdt = sdt instanceof Map ? sdt : new Map(Object.entries(sdt)) as SyntaxTransformerMap<ASTNodeType>;
        }
        public getCFG() {
            return this.cfg;
        }
        public getParseTable() {
            return this.parseTable;
        }
        public parse(tokens: Iterator<Token>): ParseTree<ASTNodeType> {
            const LLT = this.parseTable;
            const P = this.cfg.getRuleList();
            const ts = createPeekableIterator(tokens);
            const MARKER = Symbol();
        
            const T: ParseTree<ASTNodeType> = new ArrayTree() as ParseTree<ASTNodeType>;
            type StackT = NonTerminal | Terminal | typeof MARKER | typeof CFG.LAMBDA_CHARACTER;
            const K: Stack<StackT> = [];
        
            let Current: ArrayTree = T as ArrayTree;
            K.push(this.cfg.startingSymbol);
        
            while(K.length) {
                let x: StackT | Token = K.pop()!;
                if(x === MARKER) {
                    // Hold a reference to the current parrent
                    const parent = Current.parent as ArrayTree;

                    // Disjoin completed node
                    const node = parent.pop() as StrayTree<NonTerminal>;
                    let rvalue: any = node;
                    
                    // Apply wildcard transforms
                    if(this.sdt.has('*')) {
                        rvalue = this.sdt.get('*')(node);
                        if(rvalue === undefined) {
                            rvalue = node;
                        }
                    }

                    // Apply NonTerminal specific transforms
                    if(rvalue === node && this.sdt.has(node.value)) {
                        rvalue = this.sdt.get(node.value)(node);
                        if(rvalue === undefined) {
                            rvalue = node;
                        }
                    }
                    
                    // Restore connections
                    if(Array.isArray(rvalue)) {
                        parent.push(...rvalue);
                    } else if(rvalue != null) {
                        parent.push(rvalue);
                    }

                    // Continue parsing
                    Current = parent;
                } else if(CFG.isNonTerminal(x)) {
                    let p = P[LLT.get(x)?.get(ts.peek()?.name as Terminal) ?? throws(new Error(`Syntax Error: Unexpected token ${ts.peek()?.name ?? 'EOF'}`))] ?? throws(new Error(`Syntax Error: Unexpected token ${ts.peek()?.name ?? 'EOF'}`));
                    K.push(MARKER);
                    const R = p[1];
                    
                    if(this.cfg.isStartingRule(p)) {
                        K.push(CFG.EOF);
                    }
        
                    if(R.length) {
                        K.push(...[...R].reverse());
                    } else {
                        K.push(CFG.LAMBDA_CHARACTER);
                    }
        
                    const n = new Tree<TreeT>(x);
                    Current.push(n);
                    Current = Current.at(-1)!;
                } else if(CFG.isTerminalOrEOF(x) || CFG.isLambda(x)) {
                    if(CFG.isTerminalOrEOF(x)) {
                        if(x !== ts.peek()?.name as Terminal) {
                            throw new Error(`Syntax Error: Unexpected token ${ts.peek()?.name ?? 'EOF'} expected ${x}`);
                        }
                        x = ts.shift()!;
                    }
                    Current.push(new Tree(x??CFG.EOF_CHARACTER));
                }
            }
        
            if(T.length !== 1) {
                throw new Error(`Syntax Error`);
            }
        
            return T.pop()!;
        }
    }

    export namespace LL1Parser {
        
    }
}

import LL1Parser = LL1.LL1Parser;