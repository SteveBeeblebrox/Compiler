console.clear()


namespace DecoratorFactory {
    function isDecoratorContext(arg: unknown): arg is DecoratorContext {
        return typeof arg === 'object' && arg !== null && ['kind','name'].every(key=>Object.hasOwn(arg,key))
    }
    function isFactoryCall(...args: unknown[]) {
        return !((typeof args[0] === 'function' || typeof args[0] === 'undefined') && isDecoratorContext(args[1])); 
    }
    export function invokeDefault(value: Class | Function, context: DecoratorContext, ...args: unknown[]) {
        return context.kind === 'class' ? new (value as DecoratorFactory.Class)(...args) : (value as DecoratorFactory.Function)(...args)
    }
    export function decorator<Context extends DecoratorContext, Args extends Array<unknown>,Value,Return extends Function | void>(f: (value: Value, context: Context, ...args: Partial<Args>) => Return) {
        function decorate(...args: Partial<Args>): (value: Value, context: Context)=>Return;
        function decorate(value: Value, context: Context): Return;
        function decorate(...args: Partial<Args> | [Value, Context]) {
            if(isFactoryCall(...args)) {
                return (value: Value, context: Context) => value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,args) : f(value, context, ...args as Args);
            } else {
                const [value, context] = args as [Value, Context];
                return value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,[] as unknown[] as Args) : f(value, context, ...([] as unknown[] as Args));
            }
        }
        return decorate;
    }
    export type Class<A extends Array<unknown> = any[], R = any> = new (...args: A) => R;
    export type Function<A extends Array<unknown> = any[], R = any> = (...args: A) => R
}

namespace KITSUNE_NAMESPACE {
    export const addLazyDecoratorSymbol = Symbol('addLazyDecorator');
}

///#pragma once
type SubTree<K extends Tree = Tree> = K & { parent: Tree };
type StrayTree<K extends Tree = Tree> = K & { parent: undefined };

abstract class Tree {
    readonly #children: SubTree<typeof this>[] = [];
    #parent: typeof this | undefined = undefined;

    get parent(): typeof this | undefined {
        return this.#parent;
    }

    #disown(other: undefined): undefined;
    #disown(other: typeof this): StrayTree<typeof this>;
    #disown(other: typeof this | undefined): StrayTree<typeof this> | undefined;
    #disown(other: typeof this | undefined): StrayTree<typeof this> | undefined {
        if (other !== undefined) {
            other.#parent = undefined;
        }
        return other as StrayTree<typeof this> | undefined;
    }

    #own(other: undefined): never;
    #own(other: Tree): SubTree<typeof this>;
    #own(other: Tree | undefined): SubTree<typeof this>;
    #own(other: Tree | undefined): SubTree<typeof this> {
        if (other === undefined) {
            throw new Error('Cannot take ownership of undefined');
        }
        if (other === this) {
            throw new Error('Cannot take ownership of self');
        }
        if (other.parent !== undefined) {
            throw new Error('Cannot take ownership of a subtree');
        }

        let ancestor: typeof this | undefined = this;
        do {
            if (ancestor === other) {
                throw new Error('Cannot take ownership of ancestor');
            }
        } while (ancestor = ancestor.parent);

        other.#parent = this;
        return other as SubTree<typeof this>;
    }

    protected push(...items: typeof this[]): number {
        return this.#children.push(...items.map(tree => this.#own(tree)));
    }
    protected pop(): StrayTree<typeof this> | undefined {
        return this.#disown(this.#children.pop());
    }

    protected unshift(...items: typeof this[]): number {
        return this.#children.unshift(...items.map(tree => this.#own(tree)));
    }
    protected shift(): StrayTree<typeof this> | undefined {
        return this.#disown(this.#children.shift());
    }

    protected splice(start: number, deleteCount?: number | undefined): StrayTree<typeof this>[];
    protected splice(start: number, deleteCount: number, ...items: typeof this[]): StrayTree<typeof this>[];
    protected splice(start: number, deleteCount: number, ...items: typeof this[]): StrayTree<typeof this>[] {
        return this.#children.splice(start, deleteCount, ...items.map(tree => this.#own(tree))).map(tree => this.#disown(tree));
    }

    protected at(index: number): SubTree<typeof this> | undefined {
        return this.#children.at(index) as SubTree<typeof this> | undefined;
    }

    protected get length(): number {
        return this.#children.length;
    }

    protected forEach(callbackfn: (value: SubTree<typeof this>, index: number, parent: typeof this) => void, thisArg?: any): void {
        if (thisArg !== undefined) {
            callbackfn = callbackfn.bind(thisArg);
        }
        return this.#children.forEach((tree, index) => callbackfn(tree, index, this));
    }

    protected values(): IterableIterator<typeof this> {
        return this.#children.values();
    }

    get [Symbol.toStringTag]() {
        return 'Tree';
    }

    protected [Symbol.iterator]() {
        return this.#children[Symbol.iterator]();
    }
}

const enumerable = DecoratorFactory.decorator((_,context: ClassGetterDecoratorContext | ClassFieldDecoratorContext | ClassAccessorDecoratorContext, enumerable: boolean = true) => context.addInitializer(function() {
    Object.defineProperty(this, context.name, {...Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this),context.name), enumerable});
}));

type ArrayTreeMethods = Pick<Array<ArrayTree>, 'length' | 'values' | 'at' | 'push' | 'unshift' | 'pop' | 'shift' | 'splice' | typeof Symbol.iterator>;
class ArrayTree extends Tree implements ArrayTreeMethods {
    public override get length() {
        return super.length;
    }

    public override at = super.at;
    public override values = super.values;
    public override push = super.push;
    public override unshift = super.unshift;
    public override pop = super.pop;
    public override shift = super.shift;
    public override splice = super.splice;
    public override [Symbol.iterator] = super[Symbol.iterator];

    @enumerable
    get children() {
        return [...this];
    }
    
    get [Symbol.toStringTag]() {
        return 'ArrayTree';
    }
}

class BinaryTree extends Tree {
    set left(value: Tree) {
        this.splice(0,1,value);
    }
    @enumerable get left(): Tree | undefined {
        return this.at(0)
    }
    set right(value: Tree) {
        this.splice(1,1,value);
    }
    @enumerable get right(): Tree | undefined {
        return this.at(1)
    }
}

const x = new ArrayTree();
x.push(new ArrayTree())
x.at(0)
console.log(x)
console.log(new BinaryTree())
console.log(new BinaryTree())


















































console.clear();


declare namespace OpaqueTypes {
    const type: unique symbol;
    export type Opaque<T,Ident> = T & {[type]:Ident};
}
type Opaque<T,Ident> = OpaqueTypes.Opaque<T,Ident>;

class Base {

}


type self = Opaque<unknown,'self'>;
// type ResolveSelfType<T> = ;

class Derived<T extends Base = Base, InferedType = NoInfer<T extends self ? Derived<T> : T>> extends Base {
    constructor(public value?: InferedType) {super();};
    a=1
    get it() {
        return this.value!
    }
}

class Other extends Base {}


const x = new Derived(new Base())
const y = new Derived<self>(new Other());
const k = new Derived<self>(new Derived<Other>());
const n = new Derived<self>(new Derived<Base>());
const m = new Derived<self>(new Derived<self>());
const j = new Derived(new Derived());
k.it
const z = new Derived(new Other());
















































































































console.clear()


namespace DecoratorFactory {
    function isDecoratorContext(arg: unknown): arg is DecoratorContext {
        return typeof arg === 'object' && arg !== null && ['kind','name'].every(key=>Object.hasOwn(arg,key))
    }
    function isFactoryCall(...args: unknown[]) {
        return !((typeof args[0] === 'function' || typeof args[0] === 'undefined') && isDecoratorContext(args[1])); 
    }
    export function invokeDefault(value: Class | Function, context: DecoratorContext, ...args: unknown[]) {
        return context.kind === 'class' ? new (value as DecoratorFactory.Class)(...args) : (value as DecoratorFactory.Function)(...args)
    }
    export function decorator<Context extends DecoratorContext, Args extends Array<unknown>,Value,Return extends Function | void>(f: (value: Value, context: Context, ...args: Partial<Args>) => Return) {
        function decorate(...args: Partial<Args>): (value: Value, context: Context)=>Return;
        function decorate(value: Value, context: Context): Return;
        function decorate(...args: Partial<Args> | [Value, Context]) {
            if(isFactoryCall(...args)) {
                return (value: Value, context: Context) => value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,args) : f(value, context, ...args as Args);
            } else {
                const [value, context] = args as [Value, Context];
                return value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,[] as unknown[] as Args) : f(value, context, ...([] as unknown[] as Args));
            }
        }
        return decorate;
    }
    export type Class<A extends Array<unknown> = any[], R = any> = new (...args: A) => R;
    export type Function<A extends Array<unknown> = any[], R = any> = (...args: A) => R
}

namespace KITSUNE_NAMESPACE {
    export const addLazyDecoratorSymbol = Symbol('addLazyDecorator');
}

///#pragma once
const enumerable = DecoratorFactory.decorator((_,context: ClassGetterDecoratorContext | ClassFieldDecoratorContext | ClassAccessorDecoratorContext, enumerable: boolean = true) => context.addInitializer(function() {
    Object.defineProperty(this, context.name, {...Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this),context.name), enumerable});
}));

type SubTree<K extends Tree = Tree> = K & { parent: Tree };
type StrayTree<K extends Tree = Tree> = K & { parent: undefined };

abstract class Tree {
    readonly #children: SubTree<Tree>[] = [];
    #parent: Tree | undefined = undefined;

    get parent(): Tree | undefined {
        return this.#parent;
    }

    #disown(other: undefined): undefined;
    #disown(other: Tree): StrayTree<Tree>;
    #disown(other: Tree | undefined): StrayTree<Tree> | undefined;
    #disown(other: Tree | undefined): StrayTree<Tree> | undefined {
        if (other !== undefined) {
            other.#parent = undefined;
        }
        return other as StrayTree<Tree> | undefined;
    }

    #own(other: undefined): never;
    #own(other: Tree): SubTree<Tree>;
    #own(other: Tree | undefined): SubTree<Tree>;
    #own(other: Tree | undefined): SubTree<Tree> {
        if (other === undefined) {
            throw new Error('Cannot take ownership of undefined');
        }
        if (other === this) {
            throw new Error('Cannot take ownership of self');
        }
        if (other.parent !== undefined) {
            throw new Error('Cannot take ownership of a subtree');
        }

        let ancestor: Tree | undefined = this;
        do {
            if (ancestor === other) {
                throw new Error('Cannot take ownership of ancestor');
            }
        } while (ancestor = ancestor.parent);

        other.#parent = this;
        return other as SubTree<Tree>;
    }

    protected push(...items: Tree[]): number {
        return this.#children.push(...items.map(tree => this.#own(tree)));
    }
    protected pop(): StrayTree<Tree> | undefined {
        return this.#disown(this.#children.pop());
    }

    protected unshift(...items: Tree[]): number {
        return this.#children.unshift(...items.map(tree => this.#own(tree)));
    }
    protected shift(): StrayTree<Tree> | undefined {
        return this.#disown(this.#children.shift());
    }

    protected splice(start: number, deleteCount?: number | undefined): StrayTree<Tree>[];
    protected splice(start: number, deleteCount: number, ...items: Tree[]): StrayTree<Tree>[];
    protected splice(start: number, deleteCount: number, ...items: Tree[]): StrayTree<Tree>[] {
        return this.#children.splice(start, deleteCount, ...items.map(tree => this.#own(tree))).map(tree => this.#disown(tree));
    }

    protected at(index: number): SubTree<Tree> | undefined {
        return this.#children.at(index) as SubTree<Tree> | undefined;
    }

    protected get length(): number {
        return this.#children.length;
    }

    protected forEach(callbackfn: (value: SubTree<Tree>, index: number, parent: Tree) => void, thisArg?: any): void {
        if (thisArg !== undefined) {
            callbackfn = callbackfn.bind(thisArg);
        }
        return this.#children.forEach((tree, index) => callbackfn(tree, index, this));
    }

    protected values(): IterableIterator<Tree> {
        return this.#children.values();
    }

    get [Symbol.toStringTag]() {
        return 'Tree';
    }

    protected [Symbol.iterator]() {
        return this.#children[Symbol.iterator]();
    }
}

type ArrayTreeMethods = Pick<Array<Tree>, 'length' | 'values' | 'at' | 'push' | 'unshift' | 'pop' | 'shift' | 'splice' | typeof Symbol.iterator>;
class ArrayTree extends Tree implements ArrayTreeMethods {
    public override get length() {
        return super.length;
    }

    public override at = super.at;
    public override values = super.values;
    public override push = super.push;
    public override unshift = super.unshift;
    public override pop = super.pop;
    public override shift = super.shift;
    public override splice = super.splice;
    public override [Symbol.iterator] = super[Symbol.iterator];

    @enumerable get children() {
        return [...this];
    }
    
    get [Symbol.toStringTag]() {
        return 'ArrayTree';
    }
}

class BinaryTree extends Tree {
    set left(value: Tree) {
        this.splice(0,1,value);
    }
    @enumerable get left(): SubTree<Tree> | undefined {
        return this.at(0)
    }
    set right(value: Tree) {
        this.splice(1,1,value);
    }
    @enumerable get right(): SubTree<Tree> | undefined {
        return this.at(1)
    }
    get [Symbol.toStringTag]() {
        return 'BinaryTree';
    }
    args: Tree[]
    bargs: {a: Tree}
    foo(t: Tree,x:number): Tree {
        throw 'nyi'
    }
}

class DummyTree extends Tree {}

type RestructureTreeType<Type,T extends Tree> =
    Type extends Tree ? NestedTree<T>
    // : Type extends SubTree<any> ?   NestedSubTree<T>
    // : Type extends StrayTree<any> ? NestedStrayTree<T>
    // : Type extends Function ? never //? (...args: RestructureTreeType<Parameters<Type>,T>)=>RestructureTreeType<ReturnType<Type>,T>,
    // : Type extends [...any] ? {[key in keyof Type]: RestructureTreeType<Type[key],T>}
    // : Type extends object ? {[key in keyof Type]: RestructureTreeType<Type[key],T>}
    // : Type extends (...args: infer Args) => infer ReturnType ? (...args: RestructureTreeType<Args,T>) => (RestructureTreeType<ReturnType,T>)
    : Type
    
type NestedTree<T extends Tree> = T & {[key in keyof T]: RestructureTreeType<T[key],T>}
type NestedStrayTree<T extends Tree> = StrayTree<NestedTree<T>>;
type NestedSubTree<T extends Tree> = SubTree<NestedTree<T>>;

const x = new ArrayTree();
x.push(new ArrayTree())
x.at(0)
console.log(x)
console.log(new BinaryTree())
console.log(new BinaryTree())
const bt = new BinaryTree()
bt.left = new BinaryTree();
bt.right = new ArrayTree();
console.log(bt)


const bt2 = new BinaryTree() as NestedTree<BinaryTree>;
bt2.left = new BinaryTree() as NestedTree<BinaryTree>;
bt2.right = new ArrayTree() as NestedTree<BinaryTree>;
bt2.foo(new ArrayTree(),0)



const a1 = new ArrayTree() as NestedTree<ArrayTree>;
a1.push(new BinaryTree())
const z: BinaryTree = a1.pop();