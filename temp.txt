console.clear()


namespace DecoratorFactory {
    function isDecoratorContext(arg: unknown): arg is DecoratorContext {
        return typeof arg === 'object' && arg !== null && ['kind','name'].every(key=>Object.hasOwn(arg,key))
    }
    function isFactoryCall(...args: unknown[]) {
        return !((typeof args[0] === 'function' || typeof args[0] === 'undefined') && isDecoratorContext(args[1])); 
    }
    export function invokeDefault(value: Class | Function, context: DecoratorContext, ...args: unknown[]) {
        return context.kind === 'class' ? new (value as DecoratorFactory.Class)(...args) : (value as DecoratorFactory.Function)(...args)
    }
    export function decorator<Context extends DecoratorContext, Args extends Array<unknown>,Value,Return extends Function | void>(f: (value: Value, context: Context, ...args: Partial<Args>) => Return) {
        function decorate(...args: Partial<Args>): (value: Value, context: Context)=>Return;
        function decorate(value: Value, context: Context): Return;
        function decorate(...args: Partial<Args> | [Value, Context]) {
            if(isFactoryCall(...args)) {
                return (value: Value, context: Context) => value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,args) : f(value, context, ...args as Args);
            } else {
                const [value, context] = args as [Value, Context];
                return value?.[KITSUNE_NAMESPACE.addLazyDecoratorSymbol] ? void value[KITSUNE_NAMESPACE.addLazyDecoratorSymbol](f,[] as unknown[] as Args) : f(value, context, ...([] as unknown[] as Args));
            }
        }
        return decorate;
    }
    export type Class<A extends Array<unknown> = any[], R = any> = new (...args: A) => R;
    export type Function<A extends Array<unknown> = any[], R = any> = (...args: A) => R
}

namespace KITSUNE_NAMESPACE {
    export const addLazyDecoratorSymbol = Symbol('addLazyDecorator');
}

///#pragma once
type SubTree<K extends Tree = Tree> = K & { parent: Tree };
type StrayTree<K extends Tree = Tree> = K & { parent: undefined };

abstract class Tree {
    readonly #children: SubTree<typeof this>[] = [];
    #parent: typeof this | undefined = undefined;

    get parent(): typeof this | undefined {
        return this.#parent;
    }

    #disown(other: undefined): undefined;
    #disown(other: typeof this): StrayTree<typeof this>;
    #disown(other: typeof this | undefined): StrayTree<typeof this> | undefined;
    #disown(other: typeof this | undefined): StrayTree<typeof this> | undefined {
        if (other !== undefined) {
            other.#parent = undefined;
        }
        return other as StrayTree<typeof this> | undefined;
    }

    #own(other: undefined): never;
    #own(other: Tree): SubTree<typeof this>;
    #own(other: Tree | undefined): SubTree<typeof this>;
    #own(other: Tree | undefined): SubTree<typeof this> {
        if (other === undefined) {
            throw new Error('Cannot take ownership of undefined');
        }
        if (other === this) {
            throw new Error('Cannot take ownership of self');
        }
        if (other.parent !== undefined) {
            throw new Error('Cannot take ownership of a subtree');
        }

        let ancestor: typeof this | undefined = this;
        do {
            if (ancestor === other) {
                throw new Error('Cannot take ownership of ancestor');
            }
        } while (ancestor = ancestor.parent);

        other.#parent = this;
        return other as SubTree<typeof this>;
    }

    protected push(...items: typeof this[]): number {
        return this.#children.push(...items.map(tree => this.#own(tree)));
    }
    protected pop(): StrayTree<typeof this> | undefined {
        return this.#disown(this.#children.pop());
    }

    protected unshift(...items: typeof this[]): number {
        return this.#children.unshift(...items.map(tree => this.#own(tree)));
    }
    protected shift(): StrayTree<typeof this> | undefined {
        return this.#disown(this.#children.shift());
    }

    protected splice(start: number, deleteCount?: number | undefined): StrayTree<typeof this>[];
    protected splice(start: number, deleteCount: number, ...items: typeof this[]): StrayTree<typeof this>[];
    protected splice(start: number, deleteCount: number, ...items: typeof this[]): StrayTree<typeof this>[] {
        return this.#children.splice(start, deleteCount, ...items.map(tree => this.#own(tree))).map(tree => this.#disown(tree));
    }

    protected at(index: number): SubTree<typeof this> | undefined {
        return this.#children.at(index) as SubTree<typeof this> | undefined;
    }

    protected get length(): number {
        return this.#children.length;
    }

    protected forEach(callbackfn: (value: SubTree<typeof this>, index: number, parent: typeof this) => void, thisArg?: any): void {
        if (thisArg !== undefined) {
            callbackfn = callbackfn.bind(thisArg);
        }
        return this.#children.forEach((tree, index) => callbackfn(tree, index, this));
    }

    protected values(): IterableIterator<typeof this> {
        return this.#children.values();
    }

    get [Symbol.toStringTag]() {
        return 'Tree';
    }

    protected [Symbol.iterator]() {
        return this.#children[Symbol.iterator]();
    }
}

const enumerable = DecoratorFactory.decorator((_,context: ClassGetterDecoratorContext | ClassFieldDecoratorContext | ClassAccessorDecoratorContext, enumerable: boolean = true) => context.addInitializer(function() {
    Object.defineProperty(this, context.name, {...Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this),context.name), enumerable});
}));

type ArrayTreeMethods = Pick<Array<ArrayTree>, 'length' | 'values' | 'at' | 'push' | 'unshift' | 'pop' | 'shift' | 'splice' | typeof Symbol.iterator>;
class ArrayTree extends Tree implements ArrayTreeMethods {
    public override get length() {
        return super.length;
    }

    public override at = super.at;
    public override values = super.values;
    public override push = super.push;
    public override unshift = super.unshift;
    public override pop = super.pop;
    public override shift = super.shift;
    public override splice = super.splice;
    public override [Symbol.iterator] = super[Symbol.iterator];

    @enumerable
    get children() {
        return [...this];
    }
    
    get [Symbol.toStringTag]() {
        return 'ArrayTree';
    }
}

class BinaryTree extends Tree {
    set left(value: Tree) {
        this.splice(0,1,value);
    }
    @enumerable get left(): Tree | undefined {
        return this.at(0)
    }
    set right(value: Tree) {
        this.splice(1,1,value);
    }
    @enumerable get right(): Tree | undefined {
        return this.at(1)
    }
}

const x = new ArrayTree();
x.push(new ArrayTree())
x.at(0)
console.log(x)
console.log(new BinaryTree())
console.log(new BinaryTree())