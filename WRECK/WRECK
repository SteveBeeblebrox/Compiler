#!/home/siana/.nvm/versions/node/v21.5.0/bin/node
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _b, _c, _d, _e, _f, _g, _h;
//@ts-expect-error
(_a = Symbol['dispose']) !== null && _a !== void 0 ? _a : (Symbol['dispose'] = Symbol('dispose'));
//@ts-expect-error
(_b = Symbol['asyncDispose']) !== null && _b !== void 0 ? _b : (Symbol['asyncDispose'] = Symbol('asyncDispose'));
(_c = globalThis['system']) !== null && _c !== void 0 ? _c : (globalThis['system'] = {
    //@ts-expect-error
    args: process.argv.slice(1),
    //@ts-expect-error
    exit: process.exit,
    readTextFileSync(path) {
        //@ts-expect-error
        return require('fs').readFileSync(path, { encoding: 'utf8' });
    },
    writeTextFileSync(path, data) {
        //@ts-expect-error
        require('fs').writeFileSync(path, data, { encoding: 'utf8' });
    },
    async createTextFileReadStream(path) {
        //@ts-expect-error
        const stream = require('fs').createReadStream(path, { encoding: 'utf8' });
        void await new Promise(function (resolve, reject) {
            stream.on('readable', resolve);
            stream.on('error', reject);
        });
        stream[Symbol.dispose] = () => { };
        return stream;
    },
    async createTextFileWriteStream(path) {
        //@ts-expect-error
        const stream = require('fs').createWriteStream(path, { encoding: 'utf8' });
        stream[Symbol.dispose] = () => { };
        return stream;
    }
});
(_d = system['createTextFileReadStream']) !== null && _d !== void 0 ? _d : (system['createTextFileReadStream'] = async function createTextFileReadStream(path) {
    //@ts-expect-error
    const file = system.openSync(path, { read: true });
    return {
        read(bytes) {
            const buf = new Uint8Array(bytes);
            file.readSync(buf);
            return new TextDecoder().decode(buf);
        },
        [Symbol.dispose]() {
            file.close();
        }
    };
});
(_e = system['createTextFileWriteStream']) !== null && _e !== void 0 ? _e : (system['createTextFileWriteStream'] = async function createTextFileWriteStream(path) {
    //@ts-expect-error
    const file = system.openSync(path, { write: true, create: true });
    return {
        write(text) {
            file.writeSync(new TextEncoder().encode(text));
        },
        [Symbol.dispose]() {
            file.close();
        }
    };
});
const throws = (e) => { throw e; };
function installPolyfill(base, pollyfill, debug = false) {
    for (const [name, func] of Object.entries(pollyfill)) {
        if (!(name in base.prototype)) {
            Object.defineProperty(base.prototype, name, { value: func, configurable: debug });
        }
    }
}
var ArrayPolyfill;
(function (ArrayPolyfill) {
    function at(index) {
        index *= 1;
        if (index >= 0) {
            return this[index];
        }
        else if (index < 0) {
            return this[this.length + index];
        }
        else {
            throw new TypeError(`Argument to at() is not a number`);
        }
    }
    ArrayPolyfill.at = at;
    function flat(depth = 1) {
        return depth ? Array.prototype.reduce.call(this, function (flattened, value) {
            if (Array.isArray(value)) {
                flattened.push.apply(flattened, flat.call(value, depth - 1));
            }
            else {
                flattened.push(value);
            }
            return flattened;
        }, []) : Array.prototype.slice.call(this);
    }
    ArrayPolyfill.flat = flat;
    function flatMap(callback, thisArg) {
        return Array.prototype.map.call(this, callback, thisArg).flat();
    }
    ArrayPolyfill.flatMap = flatMap;
})(ArrayPolyfill || (ArrayPolyfill = {}));
installPolyfill(Array, ArrayPolyfill);
var ArrayConstructorPolyfill;
(function (ArrayConstructorPolyfill) {
    function entries(arr) {
        return Array.prototype.map.apply(arr, [(t, i) => [i, t]]);
    }
    ArrayConstructorPolyfill.entries = entries;
})(ArrayConstructorPolyfill || (ArrayConstructorPolyfill = {}));
installPolyfill({ prototype: Array }, ArrayConstructorPolyfill);
var AsyncIteratorPolyfill;
(function (AsyncIteratorPolyfill) {
    const NO_INITIAL_VALUE = Symbol();
    async function* map(mapper) {
        let counter = 0;
        for await (const value of this) {
            yield mapper(value, counter);
            counter++;
        }
    }
    AsyncIteratorPolyfill.map = map;
    async function* filter(filterer) {
        let counter = 0;
        for await (const value of this) {
            if (filterer(value, counter)) {
                yield value;
            }
            counter++;
        }
    }
    AsyncIteratorPolyfill.filter = filter;
    async function* take(limit) {
        let counter = 0;
        for await (const value of this) {
            if (counter >= limit)
                break;
            yield value;
            counter++;
        }
    }
    AsyncIteratorPolyfill.take = take;
    async function* drop(limit) {
        let counter = 0;
        for await (const value of this) {
            if (counter >= limit) {
                yield value;
            }
            counter++;
        }
    }
    AsyncIteratorPolyfill.drop = drop;
    async function* flatMap(mapper) {
        let counter = 0;
        for await (const value of this) {
            yield* mapper(value, counter);
            counter++;
        }
    }
    AsyncIteratorPolyfill.flatMap = flatMap;
    async function reduce(reducer, initialValue = NO_INITIAL_VALUE) {
        let accumulator = initialValue;
        let counter = 0;
        for await (const value of this) {
            if (accumulator === NO_INITIAL_VALUE) {
                accumulator = value;
                continue;
            }
            accumulator = reducer(accumulator, value, counter);
            counter++;
        }
        if (accumulator === NO_INITIAL_VALUE) {
            throw new TypeError('Must specify an initialValue if the iterable is empty.');
        }
        return accumulator;
    }
    AsyncIteratorPolyfill.reduce = reduce;
    async function toArray() {
        const result = [];
        for await (const x of this) {
            result.push(x);
        }
        return result;
    }
    AsyncIteratorPolyfill.toArray = toArray;
    async function forEach(fn) {
        let counter = 0;
        for await (const value of this) {
            fn(value, counter);
            counter++;
        }
    }
    AsyncIteratorPolyfill.forEach = forEach;
    async function some(fn) {
        let counter = 0;
        for await (const value of this) {
            if (fn(value, counter)) {
                return true;
            }
            counter++;
        }
        return false;
    }
    AsyncIteratorPolyfill.some = some;
    async function every(fn) {
        let counter = 0;
        for await (const value of this) {
            if (!fn(value, counter)) {
                return false;
            }
            counter++;
        }
        return true;
    }
    AsyncIteratorPolyfill.every = every;
    async function find(fn) {
        let counter = 0;
        for await (const value of this) {
            if (fn(value, counter)) {
                return value;
            }
            counter++;
        }
        return undefined;
    }
    AsyncIteratorPolyfill.find = find;
})(AsyncIteratorPolyfill || (AsyncIteratorPolyfill = {}));
installPolyfill({ prototype: Object.getPrototypeOf(Object.getPrototypeOf((async function* () { }).prototype)) }, AsyncIteratorPolyfill);
var AsyncIteratorShiftPolyfill;
(function (AsyncIteratorShiftPolyfill) {
    function shift(n) {
        if (n !== undefined) {
            return (async function* () {
                for (let i = 0; i < n; i++) {
                    yield this.shift();
                }
            }).apply(this);
        }
        return (async () => (await this.next()).value)();
    }
    AsyncIteratorShiftPolyfill.shift = shift;
})(AsyncIteratorShiftPolyfill || (AsyncIteratorShiftPolyfill = {}));
installPolyfill({ prototype: Object.getPrototypeOf(Object.getPrototypeOf((async function* () { }).prototype)) }, AsyncIteratorShiftPolyfill);
var IteratorPolyfill;
(function (IteratorPolyfill) {
    const NO_INITIAL_VALUE = Symbol();
    function* map(mapper) {
        let counter = 0;
        for (const value of this) {
            yield mapper(value, counter);
            counter++;
        }
    }
    IteratorPolyfill.map = map;
    function* filter(filterer) {
        let counter = 0;
        for (const value of this) {
            if (filterer(value, counter)) {
                yield value;
            }
            counter++;
        }
    }
    IteratorPolyfill.filter = filter;
    function* take(limit) {
        let counter = 0;
        for (const value of this) {
            if (counter >= limit)
                break;
            yield value;
            counter++;
        }
    }
    IteratorPolyfill.take = take;
    function* drop(limit) {
        let counter = 0;
        for (const value of this) {
            if (counter >= limit) {
                yield value;
            }
            counter++;
        }
    }
    IteratorPolyfill.drop = drop;
    function* flatMap(mapper) {
        let counter = 0;
        for (const value of this) {
            yield* mapper(value, counter);
            counter++;
        }
    }
    IteratorPolyfill.flatMap = flatMap;
    function reduce(reducer, initialValue = NO_INITIAL_VALUE) {
        let accumulator = initialValue;
        let counter = 0;
        for (const value of this) {
            if (accumulator === NO_INITIAL_VALUE) {
                accumulator = value;
                continue;
            }
            accumulator = reducer(accumulator, value, counter);
            counter++;
        }
        if (accumulator === NO_INITIAL_VALUE) {
            throw new TypeError('Must specify an initialValue if the iterable is empty.');
        }
        return accumulator;
    }
    IteratorPolyfill.reduce = reduce;
    function toArray() {
        const result = [];
        for (const x of this) {
            result.push(x);
        }
        return result;
    }
    IteratorPolyfill.toArray = toArray;
    function forEach(fn) {
        let counter = 0;
        for (const value of this) {
            fn(value, counter);
            counter++;
        }
    }
    IteratorPolyfill.forEach = forEach;
    function some(fn) {
        let counter = 0;
        for (const value of this) {
            if (fn(value, counter)) {
                return true;
            }
            counter++;
        }
        return false;
    }
    IteratorPolyfill.some = some;
    function every(fn) {
        let counter = 0;
        for (const value of this) {
            if (!fn(value, counter)) {
                return false;
            }
            counter++;
        }
        return true;
    }
    IteratorPolyfill.every = every;
    function find(fn) {
        let counter = 0;
        for (const value of this) {
            if (fn(value, counter)) {
                return value;
            }
            counter++;
        }
        return undefined;
    }
    IteratorPolyfill.find = find;
    async function* toAsync() { yield* this; }
    IteratorPolyfill.toAsync = toAsync;
})(IteratorPolyfill || (IteratorPolyfill = {}));
installPolyfill({ prototype: Object.getPrototypeOf(Object.getPrototypeOf((function* () { }).prototype)) }, IteratorPolyfill);
var IteratorShiftPolyfill;
(function (IteratorShiftPolyfill) {
    function shift(n) {
        if (n !== undefined) {
            return (function* () {
                for (let i = 0; i < n; i++) {
                    yield this.shift();
                }
            }).apply(this);
        }
        return this.next().value;
    }
    IteratorShiftPolyfill.shift = shift;
})(IteratorShiftPolyfill || (IteratorShiftPolyfill = {}));
installPolyfill({ prototype: Object.getPrototypeOf(Object.getPrototypeOf((function* () { }).prototype)) }, IteratorShiftPolyfill);
var ObjectPolyfill;
(function (ObjectPolyfill) {
    function groupBy(values, callback) {
        return values.reduce((obj, value, index) => {
            var _a;
            const key = callback(value, index);
            obj[key] = [...((_a = obj[key]) !== null && _a !== void 0 ? _a : []), value];
            return obj;
        }, {});
    }
    ObjectPolyfill.groupBy = groupBy;
})(ObjectPolyfill || (ObjectPolyfill = {}));
installPolyfill(Object, ObjectPolyfill);
// Set Polyfill based off of work by
// Axel Rauschmayer, (c) 2021 MIT License
// https://github.com/rauschma/set-methods-polyfill
var SetPolyfill;
(function (SetPolyfill) {
    function union(other) {
        validateOther(other);
        const result = new this.constructor(this);
        for (const elem of other.keys()) {
            result.add(elem);
        }
        return result;
    }
    SetPolyfill.union = union;
    function intersection(other) {
        validateOther(other);
        let smallerElems;
        let largerHas;
        if (this.size <= other.size) {
            smallerElems = this;
            largerHas = other;
        }
        else {
            smallerElems = other.keys();
            largerHas = this;
        }
        const result = new this.constructor();
        for (const elem of smallerElems) {
            if (largerHas.has(elem)) {
                result.add(elem);
            }
        }
        return result;
    }
    SetPolyfill.intersection = intersection;
    function difference(other) {
        validateOther(other);
        const result = new this.constructor(this);
        if (this.size <= other.size) {
            for (const elem of this) {
                if (other.has(elem)) {
                    result.delete(elem);
                }
            }
        }
        else {
            for (const elem of other.keys()) {
                if (result.has(elem)) {
                    result.delete(elem);
                }
            }
        }
        return result;
    }
    SetPolyfill.difference = difference;
    function symmetricDifference(other) {
        validateOther(other);
        const result = new this.constructor(this);
        for (const elem of other.keys()) {
            if (this.has(elem)) {
                result.delete(elem);
            }
            else {
                result.add(elem);
            }
        }
        return result;
    }
    SetPolyfill.symmetricDifference = symmetricDifference;
    function isSubsetOf(other) {
        validateOther(other);
        for (const elem of this) {
            if (!other.has(elem))
                return false;
        }
        return true;
    }
    SetPolyfill.isSubsetOf = isSubsetOf;
    function isSupersetOf(other) {
        validateOther(other);
        for (const elem of other.keys()) {
            if (!this.has(elem))
                return false;
        }
        return true;
    }
    SetPolyfill.isSupersetOf = isSupersetOf;
    function isDisjointFrom(other) {
        validateOther(other);
        if (this.size <= other.size) {
            for (const elem of this) {
                if (other.has(elem))
                    return false;
            }
        }
        else {
            for (const elem of other.keys()) {
                if (this.has(elem))
                    return false;
            }
        }
        return true;
    }
    SetPolyfill.isDisjointFrom = isDisjointFrom;
    function validateOther(obj) {
        function isObject(value) {
            if (value === null)
                return false;
            const t = typeof value;
            return t === 'object' || t === 'function';
        }
        if (!isObject(obj)) {
            throw new TypeError();
        }
        const rawSize = obj.size;
        const numSize = Number(rawSize);
        if (Number.isNaN(numSize)) {
            throw new TypeError();
        }
        const has = obj.has;
        if (typeof has !== 'function') {
            throw new TypeError();
        }
        const keys = obj.keys;
        if (typeof keys !== 'function') {
            throw new TypeError();
        }
    }
})(SetPolyfill || (SetPolyfill = {}));
installPolyfill(Set, SetPolyfill);
// Nonstandard in-place set methods
var InPlaceSetPolyfill;
(function (InPlaceSetPolyfill) {
    function takeInPlace(f) {
        return function (other) {
            const result = f.bind(this)(other);
            this.clear();
            result.forEach(t => this.add(t));
            return this;
        };
    }
    InPlaceSetPolyfill.takeUnion = takeInPlace(SetPolyfill.union);
    InPlaceSetPolyfill.takeIntersection = takeInPlace(SetPolyfill.intersection);
    InPlaceSetPolyfill.takeDifference = takeInPlace(SetPolyfill.difference);
    InPlaceSetPolyfill.takeSymmetricDifference = takeInPlace(SetPolyfill.symmetricDifference);
})(InPlaceSetPolyfill || (InPlaceSetPolyfill = {}));
installPolyfill(Set, InPlaceSetPolyfill);
function* range(arg0, arg1, arg2) {
    var _a;
    function numerical(t) {
        return typeof arg0 === 'bigint' ? BigInt(t) : t;
    }
    function destr(t) {
        return typeof t === 'string' ? t.charCodeAt(0) : t;
    }
    const [min, max] = (arg1 === undefined ? [numerical(0), destr(arg0)] : [destr(arg0), destr(arg1)]);
    const step = ((_a = destr(arg2)) !== null && _a !== void 0 ? _a : numerical(1));
    let n = min;
    if (max < min) {
        throw new RangeError('Range min cannot be greater than max');
    }
    if (typeof arg0 === 'string') {
        while (n <= max) {
            yield String.fromCharCode(n);
            n += step;
        }
    }
    else {
        while (n < max) {
            yield n;
            n += step;
        }
    }
}
//`which sjs` <(mtsc -po- -tes2018 -Ilib "$0") "$@"; exit $?
var Graphviz;
(function (Graphviz) {
    // Note label overrides attributes.label which overrides using Symbol.toStringTag
    Graphviz.label = Symbol('Graphviz.label');
    Graphviz.children = Symbol('Graphviz.children');
    Graphviz.attributes = Symbol('Graphviz.attributes');
    function text(text, attributes = {}) {
        return { ...attributes, [Graphviz.label]: text };
    }
    Graphviz.text = text;
    function stringifyAttributes(attributes) {
        return attributes ? `[${Object.entries(attributes).map(([key, value]) => `${key}=${JSON.stringify(value)}`).join(', ')}]` : '';
    }
    function serialize(obj, { output } = {}) {
        const iter = (function* () {
            let start = 0;
            while (true)
                yield start++;
        })();
        const nodes = new Map();
        const data = [];
        data.push('digraph {');
        function recurse(parent, edge, obj) {
            var _a, _b, _c;
            if (typeof obj !== 'object' || obj === null)
                return;
            if (!nodes.has(obj)) {
                nodes.set(obj, `Node${iter.shift()}`);
            }
            const name = nodes.get(obj);
            const attributes = (_a = obj[Graphviz.attributes]) !== null && _a !== void 0 ? _a : {};
            if (Graphviz.label in obj)
                attributes.label = obj[Graphviz.label];
            (_b = attributes.label) !== null && _b !== void 0 ? _b : (attributes.label = Symbol.toStringTag in obj ? obj[Symbol.toStringTag] : Object.prototype.toString.apply(obj));
            data.push(`\t${name}${stringifyAttributes(attributes)}`);
            if (parent != null) {
                data.push(`${parent}->${name}${stringifyAttributes({ label: edge })}`);
            }
            const keys = (_c = obj[Graphviz.children]) !== null && _c !== void 0 ? _c : Object.keys(obj);
            for (const [key, child] of Object.entries(Array.isArray(keys) ? obj : keys)) {
                if (!Array.isArray(keys) || keys.includes(key)) {
                    if (Array.isArray(child)) {
                        for (const [i, arrayChild] of Array.entries(child)) {
                            recurse(name, `${key}[${i}]`, arrayChild);
                        }
                    }
                    else {
                        recurse(name, key, child);
                    }
                }
            }
        }
        recurse(null, null, obj);
        data.push('}');
        const text = data.join('\n');
        if (typeof output === 'string') {
            system.writeTextFileSync(output, text);
        }
        return text;
    }
    Graphviz.serialize = serialize;
})(Graphviz || (Graphviz = {}));
class Token {
    constructor(name, value, pos) {
        this.name = name;
        this.value = value;
        this.pos = pos;
    }
}
//`which sjs` <(mtsc -po- -tes2018 -Ilib "$0") "$@"; exit $?
class CFG {
    constructor(startingSymbol, rules, terminals) {
        this.startingSymbol = startingSymbol;
        this.rules = rules;
        this.terminals = terminals;
    }
    getTerminals() {
        return [...this.terminals];
    }
    getTerminalsAndEOF() {
        return [...this.terminals, CFG.EOF];
    }
    getNonTerminals() {
        return [...new Set(this.rules.keys())];
    }
    isStartingRule(rule) {
        if (typeof rule !== 'string')
            return this.isStartingRule(rule[0]);
        return rule === this.startingSymbol;
    }
    static isTerminal(string) {
        return !this.isEOF(string) && !this.isLambda(string) && string.toLowerCase() === string && string.length >= 1;
    }
    static isTerminalOrEOF(string) {
        return CFG.isEOF(string) || CFG.isTerminal(string);
    }
    static isEOF(string) {
        return string === CFG.EOF;
    }
    static isLambda(string) {
        return string === CFG.LAMBDA_CHARACTER;
    }
    static isNonTerminal(string) {
        return !this.isEOF(string) && !this.isLambda(string) && string.toLowerCase() !== string && string.length >= 1;
    }
    derivesToLambda(L, T = []) {
        var _a;
        const P = this.rules;
        for (const p of ((_a = P.get(L)) !== null && _a !== void 0 ? _a : [])) {
            if ([...T].includes(p)) {
                continue;
            }
            if (!p.length) {
                return true;
            }
            if (p.some(x => CFG.isTerminal(x))) {
                continue;
            }
            let adl = true;
            for (const X of p.filter(x => CFG.isNonTerminal(x))) {
                T.push(p);
                adl = this.derivesToLambda(X, T);
                T.pop();
                if (!adl) {
                    break;
                }
            }
            if (adl) {
                return true;
            }
        }
        return false;
    }
    firstSet([X, ...B], T = new Set()) {
        var _a;
        const P = this.rules;
        if (X === undefined) {
            return [new Set(), T];
        }
        if (CFG.isTerminalOrEOF(X)) {
            return [new Set([X]), T];
        }
        const F = new Set();
        if (!T.has(X)) {
            T.add(X);
            for (const p of ((_a = P.get(X)) !== null && _a !== void 0 ? _a : []).map(x => [X, x])) {
                const [lhs, rhs] = p;
                const [G, I] = this.firstSet(this.startingSymbol === X ? [...rhs, CFG.EOF] : rhs, T);
                F.takeUnion(G);
            }
        }
        if (this.derivesToLambda(X) && B.length) {
            const [G, I] = this.firstSet(B, T);
            F.takeUnion(G);
        }
        return [F, T];
    }
    followSet(A, T = new Set()) {
        const P = this.rules;
        if (T.has(A)) {
            return [new Set(), T];
        }
        T.add(A);
        const F = new Set();
        for (const p of [...P.entries()].flatMap(([sym, rs]) => rs.flatMap(rule => rule.includes(A) ? [[sym, rule]] : []))) {
            const [lhs, rhs] = p;
            for (const [i, gamma] of [...rhs.entries()].filter(([_, x]) => x === A)) {
                const pi = rhs.slice(i + 1);
                if (pi.length) {
                    const [G, I] = this.firstSet(pi, new Set());
                    F.takeUnion(G);
                }
                if (!pi.length || (pi.every(x => CFG.isNonTerminal(x) && this.derivesToLambda(x)))) {
                    if (this.isStartingRule(lhs)) {
                        F.add(CFG.EOF);
                    }
                    const [G, I] = this.followSet(lhs, T);
                    F.takeUnion(G);
                }
            }
        }
        return [F, T];
    }
    predictSet([lhs, rhs]) {
        const F = this.firstSet(rhs)[0];
        if (rhs.every(x => this.derivesToLambda(x))) {
            [...this.followSet(lhs)[0].values()].forEach(x => F.add(x));
        }
        return F;
    }
    getRuleList() {
        return this.rules.entries().flatMap(([lhs, rules]) => rules.flatMap(rhs => [[lhs, rhs]])).toArray();
    }
    getRuleListFor(lhs) {
        return this.rules.get(lhs).map(rhs => [lhs, rhs]);
    }
    static makeUniqueNonTerminal(cfg, name, suffix = '\'') {
        // @ts-expect-error
        while (cfg.getNonTerminals().includes(name))
            name += suffix;
        return name;
    }
    stringifyRule(rule, lhs = true) {
        if (lhs)
            return `${rule[0]} -> ${this.stringifyRule(rule, false)}`;
        else
            return (rule[1].length ? rule[1].join(' ') : CFG.LAMBDA_CHARACTER) + (this.isStartingRule(rule) ? ' ' + CFG.EOF_CHARACTER : '');
    }
    stringifySet(set) {
        return `{${set.values().map(c => c === CFG.EOF
            ? CFG.EOF_CHARACTER
            : `'${JSON.stringify(c).slice(1, -1).replace(/'/g, '\\\'').replace(/\\"/g, '"')}'`).toArray().join(', ')}}`;
    }
    static fromString(text, allowComments = true) {
        var _a;
        const cfgKeywords = Object.assign(Object.create(null), {
            ARROW: '->',
            UC_LAMBDA: CFG.LAMBDA_CHARACTER,
            LAMBDA: 'lambda',
            OR: '|',
            EOF: CFG.EOF_CHARACTER
        });
        const tokens = [];
        for (const line of text.split('\n').map(x => x.trim())) {
            if (line.startsWith('#') && allowComments)
                continue;
            tokens.push(...line.split(' ').filter(x => x));
        }
        const rules = new Map();
        let startingSymbol = null;
        const terminals = new Set();
        while (tokens.length) {
            const target = tokens.shift();
            if (tokens.shift() !== cfgKeywords.ARROW)
                throw new Error(`Expected '${cfgKeywords.ARROW}' after '${target}'!`);
            rules.set(target, (_a = rules.get(target)) !== null && _a !== void 0 ? _a : []);
            const ruleSet = rules.get(target);
            let currentRule;
            ruleSet.push(currentRule = []);
            while (tokens[1] !== cfgKeywords.ARROW && tokens.length) {
                const token = tokens.shift();
                switch (token) {
                    case cfgKeywords.LAMBDA:
                    case cfgKeywords.UC_LAMBDA:
                        break;
                    case cfgKeywords.EOF:
                        if (startingSymbol === null)
                            startingSymbol = target;
                        else if (startingSymbol !== target)
                            throw new Error(`Multiple starting rules containing '${cfgKeywords.EOF}' found!`);
                        break;
                    case cfgKeywords.OR:
                        ruleSet.push(currentRule = []);
                        break;
                    default:
                        if (CFG.isTerminal(token))
                            terminals.add(token);
                        currentRule.push(token);
                        break;
                }
            }
        }
        if (startingSymbol === null)
            throw new Error(`No starting rule containing '${cfgKeywords.EOF}' found!`);
        return new CFG(startingSymbol, rules, terminals);
    }
}
CFG.EOF = undefined;
CFG.EOF_CHARACTER = '$';
CFG.LAMBDA_CHARACTER = '\u03bb';
var DecoratorFactory;
(function (DecoratorFactory) {
    DecoratorFactory.addLazyDecoratorSymbol = Symbol('addLazyDecorator');
    function isDecoratorContext(arg) {
        return typeof arg === 'object' && arg !== null && ['kind', 'name'].every(key => Object.hasOwn(arg, key));
    }
    function isFactoryCall(...args) {
        return !((typeof args[0] === 'function' || typeof args[0] === 'undefined') && isDecoratorContext(args[1]));
    }
    function invokeDefault(value, context, ...args) {
        return context.kind === 'class' ? new value(...args) : value(...args);
    }
    DecoratorFactory.invokeDefault = invokeDefault;
    function decorator(f) {
        function decorate(...args) {
            if (isFactoryCall(...args)) {
                return (value, context) => (value === null || value === void 0 ? void 0 : value[DecoratorFactory.addLazyDecoratorSymbol]) ? void value[DecoratorFactory.addLazyDecoratorSymbol](f, args) : f(value, context, ...args);
            }
            else {
                const [value, context] = args;
                return (value === null || value === void 0 ? void 0 : value[DecoratorFactory.addLazyDecoratorSymbol]) ? void value[DecoratorFactory.addLazyDecoratorSymbol](f, []) : f(value, context, ...[]);
            }
        }
        return decorate;
    }
    DecoratorFactory.decorator = decorator;
    function getPropertyDescriptor(o, p) {
        var _a;
        if (o == null) {
            return undefined;
        }
        return (_a = Object.getOwnPropertyDescriptor(o, p)) !== null && _a !== void 0 ? _a : getPropertyDescriptor(Object.getPrototypeOf(o), p);
    }
    DecoratorFactory.getPropertyDescriptor = getPropertyDescriptor;
})(DecoratorFactory || (DecoratorFactory = {}));
const enumerable = DecoratorFactory.decorator((_, context, enumerable = true) => context.addInitializer(function () {
    Object.defineProperty(this, context.name, { ...DecoratorFactory.getPropertyDescriptor(this, context.name), enumerable });
}));
var Trees;
(function (Trees) {
    var _Tree_instances, _Tree_children, _Tree_parent, _Tree_disown, _Tree_own;
    class TreeInternals {
    }
    TreeInternals.treeLength = Symbol('Tree.treeLength');
    TreeInternals.values = Symbol('Tree.values');
    TreeInternals.at = Symbol('Tree.at');
    TreeInternals.push = Symbol('Tree.push');
    TreeInternals.unshift = Symbol('Tree.unshift');
    TreeInternals.pop = Symbol('Tree.pop');
    TreeInternals.shift = Symbol('Tree.shift');
    TreeInternals.splice = Symbol('Tree.splice');
    TreeInternals.iterator = Symbol('Tree.iterator');
    TreeInternals.forEach = Symbol('Tree.forEach');
    class Tree extends TreeInternals {
        constructor() {
            super(...arguments);
            _Tree_instances.add(this);
            _Tree_children.set(this, []);
            _Tree_parent.set(this, undefined);
        }
        get parent() {
            return __classPrivateFieldGet(this, _Tree_parent, "f");
        }
        [(_Tree_children = new WeakMap(), _Tree_parent = new WeakMap(), _Tree_instances = new WeakSet(), _Tree_disown = function _Tree_disown(other) {
            if (other !== undefined) {
                __classPrivateFieldSet(other, _Tree_parent, undefined, "f");
            }
            return other;
        }, _Tree_own = function _Tree_own(other) {
            if (other === undefined) {
                throw new Error('Cannot take ownership of undefined');
            }
            if (other === this) {
                throw new Error('Cannot take ownership of self');
            }
            if (other.parent !== undefined) {
                throw new Error('Cannot take ownership of a subtree');
            }
            let ancestor = this;
            do {
                if (ancestor === other) {
                    throw new Error('Cannot take ownership of ancestor');
                }
            } while (ancestor = ancestor.parent);
            __classPrivateFieldSet(other, _Tree_parent, this, "f");
            return other;
        }, TreeInternals.push)](...items) {
            return __classPrivateFieldGet(this, _Tree_children, "f").push(...items.map(tree => __classPrivateFieldGet(this, _Tree_instances, "m", _Tree_own).call(this, tree)));
        }
        [TreeInternals.pop]() {
            return __classPrivateFieldGet(this, _Tree_instances, "m", _Tree_disown).call(this, __classPrivateFieldGet(this, _Tree_children, "f").pop());
        }
        [TreeInternals.unshift](...items) {
            return __classPrivateFieldGet(this, _Tree_children, "f").unshift(...items.map(tree => __classPrivateFieldGet(this, _Tree_instances, "m", _Tree_own).call(this, tree)));
        }
        [TreeInternals.shift]() {
            return __classPrivateFieldGet(this, _Tree_instances, "m", _Tree_disown).call(this, __classPrivateFieldGet(this, _Tree_children, "f").shift());
        }
        [TreeInternals.splice](start, deleteCount, ...items) {
            return __classPrivateFieldGet(this, _Tree_children, "f").splice(start, deleteCount, ...items.map(tree => __classPrivateFieldGet(this, _Tree_instances, "m", _Tree_own).call(this, tree))).map(tree => __classPrivateFieldGet(this, _Tree_instances, "m", _Tree_disown).call(this, tree));
        }
        [TreeInternals.at](index) {
            return __classPrivateFieldGet(this, _Tree_children, "f").at(index);
        }
        get [TreeInternals.treeLength]() {
            return __classPrivateFieldGet(this, _Tree_children, "f").length;
        }
        [TreeInternals.forEach](callbackfn, thisArg) {
            if (thisArg !== undefined) {
                callbackfn = callbackfn.bind(thisArg);
            }
            return __classPrivateFieldGet(this, _Tree_children, "f").forEach((tree, index) => callbackfn(tree, index, this));
        }
        [TreeInternals.values]() {
            return __classPrivateFieldGet(this, _Tree_children, "f").values();
        }
        get [Symbol.toStringTag]() {
            return this.constructor.name;
        }
        [TreeInternals.iterator]() {
            return __classPrivateFieldGet(this, _Tree_children, "f")[Symbol.iterator]();
        }
    }
    Trees.Tree = Tree;
})(Trees || (Trees = {}));
var Tree = Trees.Tree;
let ArrayTree = (() => {
    var _a, _b;
    let _classSuper = Tree;
    let _instanceExtraInitializers = [];
    let _get_children_decorators;
    return _a = class ArrayTree extends _classSuper {
            constructor() {
                super(...arguments);
                this.at = (__runInitializers(this, _instanceExtraInitializers), super[Tree.at]);
                this.values = super[Tree.values];
                this.push = super[Tree.push];
                this.unshift = super[Tree.unshift];
                this.pop = super[Tree.pop];
                this.shift = super[Tree.shift];
                this.splice = super[Tree.splice];
                this[_b] = super[Tree.iterator];
            }
            get length() {
                return super[Tree.treeLength];
            }
            get children() {
                return [...this];
            }
        },
        _b = Symbol.iterator,
        (() => {
            var _c;
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create((_c = _classSuper[Symbol.metadata]) !== null && _c !== void 0 ? _c : null) : void 0;
            _get_children_decorators = [enumerable];
            __esDecorate(_a, null, _get_children_decorators, { kind: "getter", name: "children", static: false, private: false, access: { has: obj => "children" in obj, get: obj => obj.children }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
let BinaryTree = (() => {
    var _a;
    let _classSuper = Tree;
    let _instanceExtraInitializers = [];
    let _get_left_decorators;
    let _get_right_decorators;
    return _a = class BinaryTree extends _classSuper {
            set left(value) {
                this[Tree.splice](0, 1, value);
            }
            get left() {
                return this[Tree.at](0);
            }
            set right(value) {
                this[Tree.splice](1, 1, value);
            }
            get right() {
                return this[Tree.at](1);
            }
            constructor() {
                super(...arguments);
                __runInitializers(this, _instanceExtraInitializers);
            }
        },
        (() => {
            var _b;
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create((_b = _classSuper[Symbol.metadata]) !== null && _b !== void 0 ? _b : null) : void 0;
            _get_left_decorators = [enumerable];
            _get_right_decorators = [enumerable];
            __esDecorate(_a, null, _get_left_decorators, { kind: "getter", name: "left", static: false, private: false, access: { has: obj => "left" in obj, get: obj => obj.left }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _get_right_decorators, { kind: "getter", name: "right", static: false, private: false, access: { has: obj => "right" in obj, get: obj => obj.right }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
function createAsyncPeekableIterator(asyncIterable) {
    let iter = asyncIterable[Symbol.asyncIterator]();
    let next = iter.next();
    const it = (async function* () {
        let done = false, value;
        while (!done) {
            ({ done, value } = await next);
            if (!done) {
                next = iter.next();
                yield value;
            }
        }
    })();
    it.peek = async function peek() {
        return (await next).value;
    };
    return it;
}
function createPeekableIterator(iterable) {
    let iter = iterable[Symbol.iterator]();
    let next = iter.next();
    const it = (function* () {
        let done = false, value;
        while (!done) {
            ({ done, value } = next);
            if (!done) {
                next = iter.next();
                yield value;
            }
        }
    })();
    it.peek = function peek() {
        return next.value;
    };
    return it;
}
var LL1;
(function (LL1) {
    function convertLeftRecursion(cfg) {
        const newRules = new Map();
        function getTailOverrlap(a, b) {
            let overlap = [];
            let i = -1;
            while (a.at(i) === b.at(i) && a.at(i) !== undefined) {
                overlap.unshift(a.at(i--));
            }
            return overlap;
        }
        function arrayEquals(a, b) {
            return a.length === b.length && a.every((e, i) => e === b[i]);
        }
        for (const N of cfg.getNonTerminals()) {
            // Sort by descending length to ensure we see non lambda rules first
            const rules = new Set(cfg.getRuleListFor(N).sort(([lhsA, rhsA], [lhsB, rhsB]) => rhsB.length - rhsA.length));
            newRules.set(N, []);
            refactor: for (const [lhs1, rhs1, ref1] of rules.values().map(r => [...r, r])) {
                if (rhs1[0] === lhs1) {
                    for (const [lhs2, rhs2, ref2] of rules.values().map(x => [...x, x])) {
                        if (rhs1 === rhs2) {
                            continue;
                        }
                        const beta = getTailOverrlap(rhs1, rhs2);
                        if (arrayEquals(rhs2, beta)) {
                            const A = lhs1;
                            const gamma = rhs1.slice(1, rhs1.length - beta.length);
                            rules.delete(ref1);
                            rules.delete(ref2); // Don't visit again
                            const R = CFG.makeUniqueNonTerminal(cfg, N);
                            newRules.get(N).push([...beta, R]);
                            newRules.set(R, [[...gamma, ...beta, R], []]);
                            continue refactor;
                        }
                    }
                }
                newRules.get(N).push(rhs1); // No refactor happened
            }
        }
        return new CFG(cfg.startingSymbol, newRules, new Set(cfg.getTerminals()));
    }
    function leftFactor(cfg) {
        const newRules = new Map();
        for (const N of cfg.getNonTerminals()) {
            const rules = new Set(cfg.getRuleListFor(N));
            newRules.set(N, []);
            for (const [lhs1, rhs1, ref1] of rules.values().map(r => [...r, r])) {
                if (rhs1.length < 1) {
                    newRules.get(N).push(rhs1);
                    continue;
                }
                const pre1 = rhs1[0];
                const W = CFG.makeUniqueNonTerminal(cfg, N);
                let anyOverlaps = false;
                for (const [lhs2, rhs2, ref2] of rules.values().map(r => [...r, r])) {
                    const pre2 = rhs2[0];
                    if (rhs1 !== rhs2 && pre1 === pre2) {
                        if (!anyOverlaps) {
                            newRules.set(W, []);
                        }
                        anyOverlaps = true;
                        newRules.get(W).push(rhs2.slice(1));
                        rules.delete(ref2);
                    }
                }
                if (anyOverlaps) {
                    newRules.get(W).push(rhs1.slice(1));
                    newRules.get(N).push([pre1, W]);
                    rules.delete(ref1);
                }
                else {
                    newRules.get(N).push(rhs1);
                }
            }
        }
        return new CFG(cfg.startingSymbol, newRules, new Set(cfg.getTerminals()));
    }
    // Note, some of the optimizations can't see through  A -> B -> C rules
    // Ideally, we'd optimize those out first, but that's nyi (or maybe compare with first sets?)
    function transform(cfg) {
        let k;
        do {
            k = cfg.getRuleList().length;
            cfg = leftFactor(cfg);
        } while (k != cfg.getRuleList().length);
        return convertLeftRecursion(cfg);
    }
    function createParseTable(cfg) {
        const parseTable = new Map(cfg.getNonTerminals().map(N => [N, new Map(cfg.getTerminalsAndEOF().map(a => [a, -1]))]));
        let i = 0;
        for (const lhs of cfg.getNonTerminals()) {
            const rules = cfg.getRuleListFor(lhs).map(([_, rhs]) => rhs);
            const row = parseTable.get(lhs);
            for (const rhs of rules) {
                const P = cfg.predictSet([lhs, rhs]);
                for (const a of P) {
                    if (row.get(a) != -1) {
                        // Possibly implement C hack for dangling bracket here later on or just mark issue
                        throw new Error(`Grammar is not LL(1) (Caused by rules ${row.get(a)} and ${i})`);
                    }
                    else {
                        row.set(a, i);
                    }
                }
                i++;
            }
        }
        return parseTable;
    }
    class LL1Parser {
        constructor(cfg, sdt = new Map()) {
            this.cfg = transform(cfg);
            this.parseTable = createParseTable(this.cfg);
            this.sdt = sdt instanceof Map ? sdt : new Map(Object.entries(sdt));
        }
        getCFG() {
            return this.cfg;
        }
        getParseTable() {
            return this.parseTable;
        }
        parse(tokens) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            const LLT = this.parseTable;
            const P = this.cfg.getRuleList();
            const ts = createPeekableIterator(tokens);
            const MARKER = Symbol();
            const T = new ParseTreeNode();
            const K = [];
            let Current = T;
            K.push(this.cfg.startingSymbol);
            let pos = undefined;
            while (K.length) {
                let x = K.pop();
                if (x === MARKER) {
                    // Hold a reference to the current parrent
                    const parent = Current.parent;
                    // Disjoin completed node
                    const node = parent.pop();
                    let rvalue = node;
                    // Apply NonTerminal specific transforms
                    if (rvalue === node && this.sdt.has(node.name)) {
                        rvalue = this.sdt.get(node.name)(node);
                        if (rvalue === undefined) {
                            rvalue = node;
                        }
                    }
                    // Apply wildcard transforms
                    if (rvalue === node && this.sdt.has('*')) {
                        rvalue = this.sdt.get('*')(node);
                        if (rvalue === undefined) {
                            rvalue = node;
                        }
                    }
                    // Restore connections
                    if (Array.isArray(rvalue)) {
                        parent.push(...rvalue);
                    }
                    else if (rvalue != null) {
                        parent.push(rvalue);
                    }
                    // Continue parsing
                    Current = parent;
                }
                else if (CFG.isNonTerminal(x)) {
                    let p = (_f = P[(_c = (_a = LLT.get(x)) === null || _a === void 0 ? void 0 : _a.get((_b = ts.peek()) === null || _b === void 0 ? void 0 : _b.name)) !== null && _c !== void 0 ? _c : throws(new LL1Parser.SyntaxError(`Unexpected token ${(_e = (_d = ts.peek()) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : 'EOF'}`, pos))]) !== null && _f !== void 0 ? _f : throws(new LL1Parser.SyntaxError(`Syntax Error: Unexpected token ${(_h = (_g = ts.peek()) === null || _g === void 0 ? void 0 : _g.name) !== null && _h !== void 0 ? _h : 'EOF'}`, pos));
                    K.push(MARKER);
                    const R = p[1];
                    if (this.cfg.isStartingRule(p)) {
                        K.push(CFG.EOF);
                    }
                    if (R.length) {
                        K.push(...[...R].reverse());
                    }
                    else {
                        K.push(CFG.LAMBDA_CHARACTER);
                    }
                    const n = new ParseTreeNode(x);
                    Current.push(n);
                    Current = Current.at(-1);
                }
                else if (CFG.isTerminalOrEOF(x)) {
                    if (x !== ((_j = ts.peek()) === null || _j === void 0 ? void 0 : _j.name)) {
                        throw new LL1Parser.SyntaxError(`Unexpected token ${(_l = (_k = ts.peek()) === null || _k === void 0 ? void 0 : _k.name) !== null && _l !== void 0 ? _l : 'EOF'} expected ${x}`, pos);
                    }
                    x = ts.shift();
                    pos = x === null || x === void 0 ? void 0 : x.pos;
                    Current.push(x instanceof Token ? new ParseTreeTokenLeaf(x.name, x.value) : new ParseTreeEOFLeaf());
                }
                else if (CFG.isLambda(x)) {
                    Current.push(new ParseTreeLambdaLeaf());
                }
            }
            if (T.length !== 1) {
                throw new LL1Parser.SyntaxError(undefined, pos);
            }
            return T.pop();
        }
    }
    LL1.LL1Parser = LL1Parser;
    (function (LL1Parser) {
        class AbstractParseTree extends Tree {
            constructor(name) {
                super();
                this.name = name;
            }
        }
        let ParseTreeNode = (() => {
            var _a, _b;
            let _classSuper = AbstractParseTree;
            let _instanceExtraInitializers = [];
            let _get_children_decorators;
            return _a = class ParseTreeNode extends _classSuper {
                    constructor(name) {
                        super(name);
                        this.at = (__runInitializers(this, _instanceExtraInitializers), super[Tree.at]);
                        this.values = super[Tree.values];
                        this.push = super[Tree.push];
                        this.unshift = super[Tree.unshift];
                        this.pop = super[Tree.pop];
                        this.shift = super[Tree.shift];
                        this.splice = super[Tree.splice];
                        this[_b] = super[Tree.iterator];
                    }
                    get parent() {
                        return super.parent;
                    }
                    get length() {
                        return super[Tree.treeLength];
                    }
                    get children() {
                        return [...this];
                    }
                },
                _b = Symbol.iterator,
                (() => {
                    var _c;
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create((_c = _classSuper[Symbol.metadata]) !== null && _c !== void 0 ? _c : null) : void 0;
                    _get_children_decorators = [enumerable];
                    __esDecorate(_a, null, _get_children_decorators, { kind: "getter", name: "children", static: false, private: false, access: { has: obj => "children" in obj, get: obj => obj.children }, metadata: _metadata }, null, _instanceExtraInitializers);
                    if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                })(),
                _a;
        })();
        LL1Parser.ParseTreeNode = ParseTreeNode;
        class ParseTreeLambdaLeaf extends AbstractParseTree {
            constructor() { super(CFG.LAMBDA_CHARACTER); }
        }
        LL1Parser.ParseTreeLambdaLeaf = ParseTreeLambdaLeaf;
        class ParseTreeEOFLeaf extends AbstractParseTree {
            constructor() { super(CFG.EOF_CHARACTER); }
        }
        LL1Parser.ParseTreeEOFLeaf = ParseTreeEOFLeaf;
        class ParseTreeTokenLeaf extends AbstractParseTree {
            constructor(name, value) {
                super(name);
                this.value = value;
            }
        }
        LL1Parser.ParseTreeTokenLeaf = ParseTreeTokenLeaf;
        class SyntaxError extends Error {
            constructor(message, pos) {
                super(message);
                this.pos = pos;
            }
        }
        LL1Parser.SyntaxError = SyntaxError;
    })(LL1Parser = LL1.LL1Parser || (LL1.LL1Parser = {}));
    var ParseTreeNode = LL1Parser.ParseTreeNode;
    var ParseTreeLambdaLeaf = LL1Parser.ParseTreeLambdaLeaf;
    var ParseTreeEOFLeaf = LL1Parser.ParseTreeEOFLeaf;
    var ParseTreeTokenLeaf = LL1Parser.ParseTreeTokenLeaf;
})(LL1 || (LL1 = {}));
var LL1Parser = LL1.LL1Parser;
var RegexEngine;
(function (RegexEngine) {
    let NFAGen;
    (function (NFAGen) {
        class NFAContext {
            constructor(alphabet) {
                this.alphabet = alphabet;
                this.iter = (function* (i = 0) {
                    while (true)
                        yield i++;
                })();
            }
            createState() {
                return this.iter.shift();
            }
            createStates(n = 1) {
                return [...this.iter.shift(n)];
            }
            lambdaWrap(nfa) {
                const [start, end] = this.createStates(2);
                return {
                    start,
                    end,
                    edges: [[start, nfa.start], ...nfa.edges, [nfa.end, end]]
                };
            }
        }
        NFAGen.NFAContext = NFAContext;
    })(NFAGen || (NFAGen = {}));
    var NFAContext = NFAGen.NFAContext;
    let TreeNodes;
    (function (TreeNodes) {
        var _a, _b;
        class RegexNode extends Tree {
            constructor() {
                super(...arguments);
                this.name = this.constructor.name;
            }
        }
        TreeNodes.RegexNode = RegexNode;
        class AltNode extends RegexNode {
            constructor(nodes) {
                super();
                this.nodes = nodes;
            }
            getChildNodes() {
                return [...this.nodes];
            }
            clone() {
                return new this.constructor(this.nodes.map(node => node.clone()));
            }
            toNFA(ctx) {
                const [start, end] = ctx.createStates(2);
                const nfa = { start, end, edges: [] };
                for (const subgraph of this.nodes[Symbol.iterator]().map(node => node.toNFA(ctx))) {
                    nfa.edges.push([start, subgraph.start]);
                    nfa.edges.push(...subgraph.edges);
                    nfa.edges.push([subgraph.end, end]);
                }
                return ctx.lambdaWrap(nfa);
            }
        }
        TreeNodes.AltNode = AltNode;
        class SeqNode extends RegexNode {
            constructor(nodes) {
                super();
                this.nodes = nodes;
            }
            getChildNodes() {
                return [...this.nodes];
            }
            clone() {
                return new this.constructor(this.nodes.map(node => node.clone()));
            }
            toNFA(ctx) {
                const [start, end] = ctx.createStates(2);
                const nfa = { start, end, edges: [] };
                let prev = nfa.start;
                for (const subgraph of this.nodes[Symbol.iterator]().map(node => node.toNFA(ctx))) {
                    nfa.edges.push([prev, subgraph.start]);
                    nfa.edges.push(...subgraph.edges);
                    prev = subgraph.end;
                }
                nfa.edges.push([prev, nfa.end]);
                return ctx.lambdaWrap(nfa);
            }
        }
        TreeNodes.SeqNode = SeqNode;
        class RangeNode extends RegexNode {
            constructor(min, max) {
                super();
                this.min = min;
                this.max = max;
            }
            get [Graphviz.children]() {
                return {
                    min: Graphviz.text(this.min),
                    max: Graphviz.text(this.max),
                };
            }
            clone() {
                return new this.constructor(this.min, this.max);
            }
            toNFA(ctx) {
                const [start, end] = ctx.createStates(2);
                return ctx.lambdaWrap({
                    start,
                    end,
                    edges: range(this.min, this.max).filter(char => ctx.alphabet.has(char)).map(char => [start, end, char]).toArray()
                });
            }
        }
        TreeNodes.RangeNode = RangeNode;
        class KleenNode extends RegexNode {
            constructor(node) {
                super();
                this.node = node;
                this[_a] = '*';
            }
            clone() {
                return new this.constructor(this.node.clone());
            }
            toNFA(ctx) {
                const state = ctx.createState();
                const nfa = { start: state, end: state, edges: [] };
                const subgraph = this.node.toNFA(ctx);
                nfa.edges.push([state, subgraph.start]);
                nfa.edges.push(...subgraph.edges);
                nfa.edges.push([subgraph.end, state]);
                return ctx.lambdaWrap(nfa);
            }
        }
        _a = Graphviz.label;
        TreeNodes.KleenNode = KleenNode;
        class CharNode extends RegexNode {
            constructor(char) {
                super();
                this.char = char;
            }
            get [Graphviz.label]() {
                return this.char;
            }
            clone() {
                return new this.constructor(this.char);
            }
            toNFA(ctx) {
                const [start, end] = ctx.createStates(2);
                return ctx.lambdaWrap({
                    start,
                    end,
                    edges: [[start, end, this.char]]
                });
            }
        }
        TreeNodes.CharNode = CharNode;
        class WildcharNode extends RegexNode {
            // TODO, it might be better to support wildchars and charsets in the matcher to reduce nfa size?
            clone() {
                return new this.constructor();
            }
            toNFA(ctx) {
                const [start, end] = ctx.createStates(2);
                return ctx.lambdaWrap({
                    start,
                    end,
                    edges: ctx.alphabet.values().map(char => [start, end, char]).toArray()
                });
            }
        }
        TreeNodes.WildcharNode = WildcharNode;
        class LambdaNode extends RegexNode {
            constructor() {
                super(...arguments);
                this[_b] = CFG.LAMBDA_CHARACTER;
            }
            clone() {
                return new this.constructor();
            }
            toNFA(ctx) {
                const [start, end] = ctx.createStates(2);
                return ctx.lambdaWrap({
                    start,
                    end,
                    edges: [[start, end]]
                });
            }
        }
        _b = Graphviz.label;
        TreeNodes.LambdaNode = LambdaNode;
    })(TreeNodes || (TreeNodes = {}));
    var RegexNode = TreeNodes.RegexNode;
    const GRAMMAR = CFG.fromString(new TextDecoder().decode(new Uint8Array([
        0x53, 0x20, 0x2d, 0x3e, 0x20, 0x52, 0x65, 0x67, 0x65, 0x78, 0x20, 0x24, 0xd, 0xa, 0xd, 0xa, 0x52, 0x65, 0x67, 0x65, 0x78, 0x20, 0x2d, 0x3e, 0x20, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xd, 0xa, 0xd, 0xa, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x2d, 0x3e, 0x20, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x25, 0x7c, 0x20, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0xd, 0xa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0xd, 0xa, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x2d, 0x3e, 0x20, 0x53, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x51, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x7c, 0x20, 0xce, 0xbb, 0xd, 0xa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x51, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0xd, 0xa, 0x51, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x2d, 0x3e, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x25, 0x2a, 0xd, 0xa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x25, 0x2b, 0xd, 0xa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0xd, 0xa, 0xd, 0xa, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x2d, 0x3e, 0x20, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x7c, 0x20, 0x25, 0x28, 0x20, 0x52, 0x65, 0x67, 0x65, 0x78, 0x20, 0x25, 0x29, 0xd, 0xa, 0x50, 0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x2d, 0x3e, 0x20, 0x63, 0x68, 0x61, 0x72, 0x20, 0x7c, 0x20, 0x63, 0x68, 0x61, 0x72, 0x20, 0x25, 0x2d, 0x20, 0x63, 0x68, 0x61, 0x72, 0x20, 0x7c, 0x20, 0x25, 0x2e
    ])));
    const PARSER = new LL1Parser(GRAMMAR, new Map(Object.entries({
        '*'(node) {
            if (node.length === 1) {
                if (node.at(0) instanceof LL1Parser.ParseTreeLambdaLeaf) {
                    // Remove empty lambdas
                    return null;
                }
                else {
                    // Squish tree
                    return node.pop();
                }
            }
            else if (node.name.endsWith('\'')) {
                // Simplify generated nodes
                return node.splice(0, node.length);
            }
        },
        Primitive(node) {
            const [first, , second] = [...node];
            if (first.name === 'char' && (second === null || second === void 0 ? void 0 : second.name) === 'char') {
                return new TreeNodes.RangeNode(first.value, second.value);
            }
            else if (first.name === 'char') {
                return new TreeNodes.CharNode(first.value);
            }
            else if (first.name === '%.') {
                return new TreeNodes.WildcharNode();
            }
        },
        Sequence(node) {
            if (node.length === 1)
                return node.shift();
            return new TreeNodes.SeqNode([...node].flatMap(node => node instanceof TreeNodes.SeqNode ? node.getChildNodes() : [node]));
        },
        Alternation(node) {
            const l = node.length;
            const children = node.splice(0, node.length).filter(x => x instanceof RegexNode);
            // Joining n items requires n-1 separators. if 2n-1 != num children, there exists an extra %|
            if (2 * children.length - 1 !== l) {
                children.push(new TreeNodes.LambdaNode());
            }
            return new TreeNodes.AltNode(children); // Todo, flatten this?
        },
        Quantifier(node) {
            const mod = node.at(1);
            if (mod instanceof LL1Parser.ParseTreeTokenLeaf) {
                switch (mod.name) {
                    case '%+': return new TreeNodes.SeqNode([node.at(0), new TreeNodes.KleenNode(node.shift().clone())]);
                    case '%*': return new TreeNodes.KleenNode(node.shift());
                }
            }
        },
        Primary(node) {
            return node.length === 1 ? node.shift() : node.splice(1, 1);
        },
        S(node) {
            return node.shift();
        }
    })));
    function isHex(text) {
        return text.split('').every(c => '0123456789abcdef'.includes(c.toLowerCase()));
    }
    function* tokenize(text) {
        const iter = text[Symbol.iterator]();
        let c;
        let col = 0, line = 1;
        while ((c = iter.shift()) !== undefined) {
            switch (c) {
                case '\\':
                    {
                        const e = iter.shift();
                        switch (e) {
                            case '\\':
                            case '(':
                            case ')':
                            case '+':
                            case '*':
                            case '-':
                            case '.':
                            case '|':
                                yield new Token('char', e, { line, col });
                                break;
                            case 's':
                                yield new Token('char', ' ', { line, col });
                                break;
                            case 'n':
                                yield new Token('char', '\n', { line, col });
                                break;
                            case 'u':
                                const hex = iter.take(4).toArray().join('');
                                const n = Number.parseInt(hex, 16);
                                if (hex.length != 4 || !isHex(hex) || Number.isNaN(n)) {
                                    throw new Error(`Invalid unicode escape sequence '\\u${hex}'`);
                                }
                                yield new Token('char', String.fromCharCode(n), { line, col });
                                break;
                            default:
                                throw new Error(`Unknown escape sequence '\\${e}'`);
                        }
                        break;
                    }
                    ;
                case '(':
                case ')':
                case '+':
                case '*':
                case '-':
                case '.':
                case '|':
                    yield new Token('%' + c, c, { line, col });
                    break;
                default:
                    yield new Token('char', c, { line, col });
                    break;
            }
            if (c === '\n')
                line++;
            col++;
        }
    }
    RegexEngine.tokenize = tokenize;
    function parse(text) {
        return PARSER.parse(tokenize(text));
    }
    RegexEngine.parse = parse;
    function compile(text, alphabet) {
        const ctx = new NFAContext(new Set(alphabet));
        const [start, end] = ctx.createStates(2);
        const ast = RegexEngine.parse(text);
        const nfa = ast.toNFA(ctx);
        return {
            start,
            end,
            edges: [[start, nfa.start], ...nfa.edges, [nfa.end, end]],
        };
    }
    RegexEngine.compile = compile;
})(RegexEngine || (RegexEngine = {}));
var AlphabetEncoding;
(function (AlphabetEncoding) {
    function decode(encoded) {
        function unescape(sequence) {
            const n = +`0${sequence}`;
            if (Number.isNaN(n))
                throw new Error(`'${sequence}' is not a valid escape sequence!`);
            return String.fromCharCode(n);
        }
        return encoded === null || encoded === void 0 ? void 0 : encoded.replace(/x.{0,2}/g, unescape);
    }
    AlphabetEncoding.decode = decode;
    function encode(text, force = false) {
        function escape(char) {
            return `x${char.charCodeAt(0).toString(16).padStart(2, '0')}`;
        }
        return force ? text[Symbol.iterator]().map(escape).toArray().join('') : text === null || text === void 0 ? void 0 : text.replace(/[^0-9A-Za-wy-z]/g, escape);
    }
    AlphabetEncoding.encode = encode;
})(AlphabetEncoding || (AlphabetEncoding = {}));
const { decode: alphaDecode, encode: alphaEncode } = AlphabetEncoding;
///<reference path="../../lib/compat.ts"/> // Make VS Code happy 
///<reference path="../../core/regex.ts"/> // Make VS Code happy
///<reference path="../../lib/encoding.ts"/> // Make VS Code happy
///<reference path="../../lib/types.ts"/> // Make VS Code happy
///<reference path="../../lib/range.ts"/> // Make VS Code happy
///<reference path="../../core/ll1.ts"/> // Make VS Code happy
const IO_ERROR = 1, SYNTAX_ERROR = 2, SEMANTIC_ERROR = 3;
if (system.args.slice(1).length < 1) {
    console.error('Expected at least one argument!');
    system.exit();
}
const [lexFile, outFile] = system.args.slice(1);
const lines = (function () {
    var _a, _b;
    try {
        return (((_a = system.readTextFileSync(lexFile)) === null || _a === void 0 ? void 0 : _a.trim()) || throws(new Error('No text!'))).split(/\r?\n/g);
    }
    catch (e) {
        console.error((_b = e === null || e === void 0 ? void 0 : e.message) !== null && _b !== void 0 ? _b : 'IO Error!');
        system.exit(IO_ERROR);
    }
})();
const alphabet = lines.shift().split(/\s+/g).flatMap(x => alphaDecode(x).split(''));
console.log(`Alphabet: ${alphabet.map(x => alphaEncode(x)).join(' ')}`);
const uFileOutput = [];
uFileOutput.push(alphabet.map(x => alphaEncode(x)).join(' '));
const lambdaCharacter = (function (alphabet) {
    for (const c of range(String.fromCharCode(1), String.fromCharCode(127))) {
        if (!alphabet.has(c))
            return c;
    }
    console.error('No sutible lambda ascii character found!');
    system.exit(8);
})(new Set(alphabet));
console.log(`Chose ${alphaEncode(lambdaCharacter)} for lambda`);
for (const line of lines) {
    const [regex, name, value] = line.split(/\s+/g);
    console.log(`Compiling ${name}...`);
    const nfa = (function () {
        try {
            return RegexEngine.compile(regex, alphabet);
        }
        catch (e) {
            if (e instanceof LL1Parser.SyntaxError) {
                console.error(`Syntax Error${e.message ? `: ${e.message}` : ''}${e.pos ? ` at ${e.pos.line}:${e.pos.col}` : ''}`);
                system.exit(SYNTAX_ERROR);
            }
            console.error(`Semantic Error${e.message ? `: ${e.message}` : ''}`);
            system.exit(SEMANTIC_ERROR);
        }
    })();
    uFileOutput.push(`${name}.tt ${name} ${value !== null && value !== void 0 ? value : ''}`.trim());
    try {
        const nfaFileOutput = [];
        nfaFileOutput.push(`${nfa.edges.length} ${alphaEncode(lambdaCharacter)} ${alphabet.map(x => alphaEncode(x)).join(' ')}`);
        for (const edge of nfa.edges) {
            nfaFileOutput.push(`${edge[1] === 1 ? '+' : '-'} ${edge[0]} ${edge[1]} ${alphaEncode((_f = edge[2]) !== null && _f !== void 0 ? _f : lambdaCharacter)}`);
        }
        system.writeTextFileSync(`${name}.nfa`, nfaFileOutput.join('\n'));
    }
    catch (e) {
        console.error((_g = e === null || e === void 0 ? void 0 : e.message) !== null && _g !== void 0 ? _g : 'IO Error!');
        system.exit(IO_ERROR);
    }
}
try {
    system.writeTextFileSync(outFile !== null && outFile !== void 0 ? outFile : lexFile.replace(/\.[^.]+$/g, '.u'), uFileOutput.join('\n'));
}
catch (e) {
    console.error((_h = e === null || e === void 0 ? void 0 : e.message) !== null && _h !== void 0 ? _h : 'IO Error!');
    system.exit(IO_ERROR);
}
